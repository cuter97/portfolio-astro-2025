const _astro_dataLayerContent = [["Map",1,2,9,10,22,227,675,676,756,757,776,777,901,902],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.14.4","content-config-digest","e4e28ce5a210a33f","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"http://localhost:4321\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":false,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"en\",\"es\"],\"routing\":{\"prefixDefaultLocale\":true,\"redirectToDefaultLocale\":true,\"fallbackType\":\"redirect\"}},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","project",["Map",11,12,38,39,64,65,86,87,108,109,134,135,154,155,172,173,190,191,207,208],"en/artesanos-del-sur",{id:11,data:13,body:34,filePath:35,digest:36,deferredRender:37},{title:14,description:15,descriptionTags:16,tags:19,pageTags:25,demoLink:32,lang:33},"Artesano del Sur","A bilingual artisan website showcasing handmade products from southern Argentina.",[17,18],"Built with Astro, Tailwind and GSAP.","Supports English and Spanish.",[20,23],{id:21,collection:22},"astro","skill",{id:24,collection:22},"tailwind",[26,27,28,30],{id:21,collection:22},{id:24,collection:22},{id:29,collection:22},"i18n",{id:31,collection:22},"gsap","https://artesanodelsur.com/","en","# Artesano del sur\r\n\r\nThis project is a digital catalog for **'Artesano del Sur'**, a brand of handcrafted products.  \r\nThe website is built with **Astro** to optimize performance, **Tailwind CSS** for fast layout styling, and **GSAP** to add smooth animations that complement the artisanal aesthetic.  \r\nThe site is bilingual and allows visitors to explore unique handmade pieces.\r\n\r\n![Screenshot of Artesano del sur website](/src/assets/img-2.webp)\r\n\r\n## Challenge and Solutions\r\n\r\n- Implemented an accessible multilingual structure using dynamic routes.\r\n- Achieved smooth animations with GSAP without compromising performance.\r\n- Leveraged Astro Islands to render only what's needed and improve load times.\r\n\r\n## Features\r\n\r\n- Responsive design with mobile-first focus\r\n- GSAP animations for smooth and engaging transitions\r\n- Bilingual navigation\r\n- Sections like story, blog, and product catalog","src/content/projects/en/artesanos-del-sur.mdx","a06c86b227b9e851",true,"en/microservices",{id:38,data:40,body:61,filePath:62,digest:63,deferredRender:37},{title:41,description:42,descriptionTags:43,tags:46,pageTags:51,githubLink:60,lang:33},"Microservices","Microservices practice with Nest.js, Docker, and NATS as the messaging system.",[44,45],"Built with Nest.js and PostgreSQL.","Using NATS as a communication system.",[47,49],{id:48,collection:22},"nest",{id:50,collection:22},"docker",[52,53,54,56,58],{id:48,collection:22},{id:50,collection:22},{id:55,collection:22},"postgresql",{id:57,collection:22},"nats",{id:59,collection:22},"typescript","https://github.com/orgs/Nest-Microservices-dev/repositories","# Microservices\r\nThis project is part of the microservices course at DevTalles Academy. It uses Nest.js to create scalable services, Docker for containerization, and NATS for asynchronous communication between microservices. The services include product management, orders, payments, and authentication.\r\n\r\n## Features\r\n\r\n- Microservices communicated via NATS\r\n- Containerization with Docker\r\n- Product, order, and payment management.\r\n\r\n## Future Improvements\r\n\r\n- Create an admin profile to dynamically add information\r\n- Improve event management and communication between microservices using advanced messaging design patterns.","src/content/projects/en/microservices.mdx","8e69f98177c8e049","en/portfolio",{id:64,data:66,body:83,filePath:84,digest:85,deferredRender:37},{title:67,description:68,descriptionTags:69,tags:71,pageTags:75,githubLink:82,lang:33},"Portfolio","A portfolio website to showcase my projects and skills.",[70,18],"Built with React, Astro and Tailwind.",[72,74],{id:73,collection:22},"react",{id:21,collection:22},[76,77,78,79,81],{id:73,collection:22},{id:21,collection:22},{id:24,collection:22},{id:80,collection:22},"shadcn",{id:31,collection:22},"https://github.com/cuter97/portfolio-astro-2025","# Portfolio Website\r\n\r\nThis project is a custom platform to showcase my work, skills, and experience in web development. Designed with a modern and minimalist approach, the portfolio offers an intuitive and visually appealing user experience.\r\n\r\n## Challenge and Solutions\r\n- Dark Mode: Implemented a dynamic system for switching between light and dark modes, enhancing accessibility and user experience personalization.\r\n- Multilanguage Support: Added support for English and Spanish, allowing users to easily switch between languages.\r\n- Responsive Design: The portfolio is fully optimized for mobile devices, ensuring smooth and responsive viewing across all screen sizes.\r\n\r\n## Features\r\n- Built with Astro, React, Tailwind CSS, and Shadcn/ui\r\n- Animations created using GSAP and Astro Transition\r\n- Language switching implemented with i18n\r\n\r\n## Future Improvements\r\n\r\n- Admin Profile: I would like to implement an admin profile to dynamically add and manage content.\r\n- Dynamic Projects Section: Automate the loading of projects from a GitHub repository.","src/content/projects/en/portfolio.mdx","ee0ff52a1ef248a8","en/shortly-api",{id:86,data:88,body:105,filePath:106,digest:107,deferredRender:37},{title:89,description:90,descriptionTags:91,tags:94,pageTags:98,githubLink:103,demoLink:104,lang:33},"Shortly API","A web user interface for creating shortened URLs using rel.ink API.",[92,93],"Built with React and SASS.","One of my first projects from 2022.",[95,96],{id:73,collection:22},{id:97,collection:22},"sass",[99,100,101],{id:73,collection:22},{id:97,collection:22},{id:102,collection:22},"css","https://github.com/cuter97/shortly-api","https://shortly-api-eta.vercel.app/","# Shortly API\r\n\r\nThis project was a frontend mentor challenge. The challenge involves integrating the rel.ink API into a web user interface to create shortened URLs, which should be displayed according to the proposed design. I took this opportunity to gain more experience with asynchronous JavaScript. It is one of my first projects and was completed in 2022.\r\n\r\n![Screenshot of Artesano del sur website](/src/assets/img-3.webp)\r\n\r\n## Challenge and Solutions\r\n\r\n- Learned to work with APIs and handle asynchronous operations effectively.\r\n- Designed the user interface to meet the specifications of the challenge.\r\n\r\n## Features\r\n\r\n- Integration with the rel.ink API for URL shortening\r\n- User-friendly interface for creating and managing shortened URLs.\r\n\r\n## Future Improvements\r\n\r\n- Enhance the user experience with additional features like link analytics and custom shortened URLs.","src/content/projects/en/shortly-api.mdx","d20463b360c3018b","en/trainingpeek",{id:108,data:110,body:131,filePath:132,digest:133,deferredRender:37},{title:111,description:112,descriptionTags:113,tags:116,pageTags:121,demoLink:130,lang:33},"TrainingPeek","Online training platform offering various training activities.",[114,115],"Built with Next.js and Node.js.","Integrated Mercado Pago for payment.",[117,119],{id:118,collection:22},"next",{id:120,collection:22},"node",[122,123,124,125,126,128],{id:118,collection:22},{id:24,collection:22},{id:120,collection:22},{id:59,collection:22},{id:127,collection:22},"mercadopago",{id:129,collection:22},"nextui","https://trainingpeek2-0.vercel.app/","# TrainingPeek\r\n\r\nTrainingPeek is an online training platform developed to offer an intuitive and accessible user experience. It includes user and admin registration features, allowing efficient management of accounts and platform content.\r\n![Screenshot of TrainingPeek website](/src/assets/img-1.webp)\r\n\r\n## Challenge and Solutions\r\n\r\n- Performance Optimization: Implemented optimization techniques like lazy loading of images and static site generation (SSG) to improve load speed.\r\n- Responsive Design: Adapted the design to look and function correctly on mobile and desktop devices using CSS Grid and Flexbox.\r\n- Payment Gateway Integration: Incorporated the Mercado Pago payment gateway to facilitate user transactions.\r\n\r\n\r\n## Features\r\n\r\n- User and admin registration\r\n- Integration with Mercado Pago for payments\r\n- Accessible and user-friendly training platform\r\n- Responsive design for mobile and desktop devices.\r\n- UI components developed with NextUI.","src/content/projects/en/trainingpeek.mdx","a185a756603d1f94","es/microservices",{id:134,data:136,body:151,filePath:152,digest:153,deferredRender:37},{title:41,description:137,descriptionTags:138,tags:141,pageTags:144,githubLink:60,lang:150},"Práctica de microservicios con Nest.js, Docker y NATS como sistema de mensajería.",[139,140],"Construido con Nest.js y PostgreSQL.","Usando NATS como sistema de comunicación.",[142,143],{id:48,collection:22},{id:50,collection:22},[145,146,147,148,149],{id:48,collection:22},{id:50,collection:22},{id:55,collection:22},{id:57,collection:22},{id:59,collection:22},"es","# Microservices\r\nEste proyecto es parte de la cursada de microservicios en DevTalles Academy. Utiliza Nest.js para crear servicios escalables, Docker para contenerización, y NATS para comunicación asíncrona entre microservicios. Los servicios incluyen gestión de productos, pedidos, pagos, y autenticación.\r\n\r\n## Características\r\n\r\n- Microservicios comunicados via NATS\r\n- Contenerización con Docker\r\n- Gestión de productos, pedidos y pagos.\r\n\r\n## Mejoras Futuras\r\n\r\n- Crear un perfil administrador para agregar información dinámicamente.\r\n- Mejorar la gestión de eventos y comunicación entre microservicios utilizando patrones de diseño de mensajería avanzados.","src/content/projects/es/microservices.mdx","ef4e01a15d2fb864","es/artesanos-del-sur",{id:154,data:156,body:169,filePath:170,digest:171,deferredRender:37},{title:14,description:157,descriptionTags:158,tags:161,pageTags:164,demoLink:32,lang:150},"Sitio web artesanal bilingüe para mostrar productos hechos a mano en el sur de Argentina.",[159,160],"Construido con Astro, Tailwind y GSAP.","Soporte para inglés y español.",[162,163],{id:21,collection:22},{id:24,collection:22},[165,166,167,168],{id:21,collection:22},{id:24,collection:22},{id:29,collection:22},{id:31,collection:22},"# Artesano del sur\r\n\r\nEste proyecto es un catálogo digital para **'Artesano del Sur'**, una marca de productos artesanales.  \r\nEl sitio web está construido con **Astro** para optimizar el rendimiento, **Tailwind CSS** para estilizar rápidamente los diseños, y **GSAP** para añadir animaciones suaves que complementan la estética artesanal.  \r\nEl sitio es bilingüe y permite a los visitantes explorar piezas únicas hechas a mano.\r\n\r\n![Captura de pantalla del sitio web Artesano del sur](/src/assets/img-2.webp)\r\n\r\n## Desafíos y Soluciones\r\n\r\n- Implementé una estructura multilingüe accesible utilizando rutas dinámicas.\r\n- Logré animaciones fluidas con GSAP sin comprometer el rendimiento.\r\n- Aproveché Astro Islands para renderizar solo lo necesario y mejorar los tiempos de carga.\r\n\r\n## Características\r\n\r\n- Diseño responsivo con enfoque mobile-first\r\n- Animaciones GSAP para transiciones suaves y atractivas\r\n- Navegación bilingüe\r\n- Secciones como historia, blog y catálogo de productos","src/content/projects/es/artesanos-del-sur.mdx","c1dfc97a85726d09","es/portfolio",{id:172,data:174,body:187,filePath:188,digest:189,deferredRender:37},{title:67,description:175,descriptionTags:176,tags:178,pageTags:181,githubLink:185,demoLink:186,lang:150},"Este es mi portfolio web, donde muestro mis proyectos y habilidades.",[177,18],"Built with Next.js and Tailwind.",[179,180],{id:73,collection:22},{id:21,collection:22},[182,183,184],{id:73,collection:22},{id:21,collection:22},{id:24,collection:22},"https://github.com/cuter96","https://agustincastets.vercel.app/","# Portfolio Website\r\n\r\nEste proyecto es una plataforma personalizada para mostrar mi trabajo, habilidades y experiencia en desarrollo web. Diseñado con un enfoque moderno y minimalista, el portfolio ofrece una experiencia de usuario intuitiva y visualmente atractiva.\r\n\r\n## Desafíos y Soluciones\r\n- Modo Oscuro: Implementé un sistema dinámico para cambiar entre modos claro y oscuro, mejorando la accesibilidad y la personalización de la experiencia de usuario.\r\n- Soporte Multilingüe: Añadí soporte para inglés y español, permitiendo a los usuarios cambiar fácilmente entre idiomas.\r\n- Diseño Responsivo: El portfolio está totalmente optimizado para dispositivos móviles, garantizando una visualización suave y receptiva en todos los tamaños de pantalla.\r\n\r\n## Características\r\n\r\n- Construido con Astro, React, Tailwind CSS y Shadcn/ui\r\n- Animaciones creadas con GSAP y Astro Transition\r\n- Intercambio de idiomas implementado con i18n\r\n\r\n## Mejoras Futuras\r\n\r\n- Perfil Administrador: Quiero implementar un perfil administrador para agregar y gestionar contenido dinámicamente.\r\n- Sección de Proyectos Dinámica: Automatizar la carga de proyectos desde un repositorio de GitHub.","src/content/projects/es/portfolio.mdx","b290bfd5dee1cf04","es/shortly-api",{id:190,data:192,body:204,filePath:205,digest:206,deferredRender:37},{title:89,description:193,descriptionTags:194,tags:197,pageTags:200,githubLink:103,demoLink:104,lang:150},"Una interfaz de usuario web para crear URLs acortadas con la API de rel.ink.",[195,196],"Construido con React y SASS.","Uno de mis primeros proyectos de 2022.",[198,199],{id:73,collection:22},{id:97,collection:22},[201,202,203],{id:73,collection:22},{id:97,collection:22},{id:102,collection:22},"# Shortly API\r\n\r\nEste proyecto fue un desafío de Frontend Mentor. El desafío implica integrar la API rel.ink en una interfaz de usuario web para crear URLs acortadas, que deben mostrarse de acuerdo al diseño propuesto. Tomé esta oportunidad para adquirir más experiencia con JavaScript asíncrono. Es uno de mis primeros proyectos y se completó en 2022.\r\n\r\n![Screenshot de Shortly API website](/src/assets/img-3.webp)\r\n\r\n## Desafíos y Soluciones\r\n\r\n- Aprendí a trabajar con APIs y manejar operaciones asíncronas de manera efectiva.\r\n- Diseñé la interfaz de usuario para cumplir con las especificaciones del desafío.\r\n\r\n## Características\r\n\r\n- Integración con la API rel.ink para acortar URLs\r\n- Interfaz de usuario amigable para crear y gestionar URLs acortadas.\r\n\r\n## Mejoras Futuras\r\n\r\n- Mejorar la experiencia del usuario con características adicionales como análisis de enlaces y URLs acortadas personalizadas.","src/content/projects/es/shortly-api.mdx","05bb39999379fca4","es/trainingpeek",{id:207,data:209,body:224,filePath:225,digest:226,deferredRender:37},{title:111,description:210,descriptionTags:211,tags:214,pageTags:217,demoLink:130,lang:150},"Plataforma de entrenamiento en línea que ofrece diversas actividades de entrenamiento.",[212,213],"Construido con Next.js y Node.js.","Integración de Mercado Pago para pagos.",[215,216],{id:118,collection:22},{id:120,collection:22},[218,219,220,221,222,223],{id:118,collection:22},{id:24,collection:22},{id:120,collection:22},{id:59,collection:22},{id:127,collection:22},{id:129,collection:22},"# TrainingPeek\r\n\r\nTrainingPeek es una plataforma de entrenamiento en línea desarrollada para ofrecer una experiencia de usuario intuitiva y accesible. Incluye funciones de registro de usuarios y administradores, permitiendo una gestión eficiente de cuentas y contenido de la plataforma.\r\n![Screenshot de TrainingPeek website](/src/assets/img-1.webp)\r\n\r\n## Desafíos y Soluciones  \r\n\r\n- Optimización de rendimiento: Implementé técnicas de optimización como carga diferida de imágenes y generación estática de sitios (SSG) para mejorar la velocidad de carga.\r\n- Diseño responsivo: Adapté el diseño para que se vea y funcione correctamente en dispositivos móviles y de escritorio utilizando CSS Grid y Flexbox.\r\n- Integración de pasarela de pago: Incorporé la pasarela de pago de Mercado Pago para facilitar las transacciones de los usuarios.\r\n\r\n\r\n## Características\r\n\r\n- Registro de usuarios y administradores\r\n- Integración con Mercado Pago para pagos\r\n- Plataforma de entrenamiento accesible y fácil de usar\r\n- Diseño responsivo para dispositivos móviles y de escritorio.\r\n- Componentes de interfaz desarrollados con NextUI.","src/content/projects/es/trainingpeek.mdx","af5f83ab2d563e02",["Map",228,229,236,237,244,245,252,253,261,262,271,272,280,281,289,290,297,298,306,307,313,314,321,322,330,331,339,340,348,349,356,357,365,366,373,374,381,382,389,390,397,398,406,407,414,415,422,423,429,430,438,439,447,448,456,457,464,465,472,473,479,480,486,487,493,494,500,501,507,508,514,515,521,522,528,529,535,536,542,543,549,550,556,557,563,564,570,571,577,578,584,585,591,592,598,599,605,606,612,613,619,620,626,627,633,634,640,641,647,648,654,655,661,662,668,669],"en/astro",{id:228,data:230,filePath:234,digest:235},{skill:231,description:232,release:233,icon:21,feed:37,lang:33},"Astro","Astro is a modern static site generator that allows you to build fast and performa websites using modern web technologies.","Released in August 2022","src/content/skills/en/astro.json","8f20c46a184b274c","en/css",{id:236,data:238,filePath:242,digest:243},{skill:239,description:240,release:241,icon:102,feed:37,lang:33},"CSS","A stylesheet language used to describe the presentation of a document written in HTML or XML.","Joined December 1996","src/content/skills/en/css.json","5345e4b8b1bac0a6","en/docker",{id:244,data:246,filePath:250,digest:251},{skill:247,description:248,release:249,icon:50,feed:37,lang:33},"Docker","A platform for developing, shipping, and running applications in containers.","Released in 2013","src/content/skills/en/docker.json","ecfd9156dbca28ff","en/express",{id:252,data:254,filePath:259,digest:260},{skill:255,description:256,release:257,icon:258,feed:37,lang:33},"Express.js","A minimal and flexible Node.js web application framework, providing a robust set of features to develop web and mobile applications.","Joined November 2010","express","src/content/skills/en/express.json","9219ddf0d7dceeeb","en/framermotion",{id:261,data:263,filePath:269,digest:270},{skill:264,description:265,release:266,icon:267,feed:268,lang:33},"Framer Motion","A library for React that enables creating smooth and high-performance animations in web applications.","Joined in April 2018","framermotion",false,"src/content/skills/en/framermotion.json","2b2b249f35156c7f","en/git",{id:271,data:273,filePath:278,digest:279},{skill:274,description:275,release:276,icon:277,feed:37,lang:33},"Git","A distributed version control system that tracks changes in source code during software development.","Released in 2005","git","src/content/skills/en/git.json","22f34d824957dd42","en/graphql",{id:280,data:282,filePath:287,digest:288},{skill:283,description:284,release:285,icon:286,feed:37,lang:33},"GraphQL","A query language for APIs and a runtime for executing those queries by using a type system defined for your data.","Joined February 2015","graphql","src/content/skills/en/graphql.json","d243915c07649d07","en/gsap",{id:289,data:291,filePath:295,digest:296},{skill:292,description:293,release:294,icon:31,feed:268,lang:33},"GSAP","GSAP (GreenSock Animation Platform) is a powerful JavaScript library for creating high-performance animations that work in all major browsers.","Released March 2008","src/content/skills/en/gsap.json","f175991c7f7fb9d9","en/html",{id:297,data:299,filePath:304,digest:305},{skill:300,description:301,release:302,icon:303,feed:37,lang:33},"HTML","HTML (HyperText Markup Language) is the standard markup language for creating web pages and web applications.","Joined October 1991","html","src/content/skills/en/html.json","34d714585494e44d","en/i18n",{id:306,data:308,filePath:311,digest:312},{skill:29,description:309,release:310,icon:29,feed:268,lang:33},"An internationalization system that allows managing multiple languages in web applications.","Joined in March 2006","src/content/skills/en/i18n.json","e780338ff03a39f8","en/mercadopago",{id:313,data:315,filePath:319,digest:320},{skill:316,description:317,release:318,icon:127,feed:268,lang:33},"Mercado Pago","An online payment platform that enables secure and efficient transactions for both merchants and consumers.","Joined in August 2004","src/content/skills/en/mercadopago.json","c66cd193762cddb3","en/javascript",{id:321,data:323,filePath:328,digest:329},{skill:324,description:325,release:326,icon:327,feed:37,lang:33},"JavaScript","A versatile programming language that is widely used for web development, both on the client and server side.","Joined December 1995","javascript","src/content/skills/en/javascript.json","8d2eaa2ed5690618","en/java",{id:330,data:332,filePath:337,digest:338},{skill:333,description:334,release:335,icon:336,feed:37,lang:33},"Java","A high-level, class-based, object-oriented programming language designed to have as few implementation dependencies as possible.","Joined in January 1996","java","src/content/skills/en/java.json","654a7c754d22c6c8","en/mongodb",{id:339,data:341,filePath:346,digest:347},{skill:342,description:343,release:344,icon:345,feed:37,lang:33},"MongoDB","MongoDB is a cross-platform document-oriented database program. Classified as a NoSQL database program, MongoDB uses JSON-like documents with optional schemas.","Joined February 2009","mongodb","src/content/skills/en/mongodb.json","2790af1b2e689a92","en/nats",{id:348,data:350,filePath:354,digest:355},{skill:351,description:352,release:353,icon:57,feed:268,lang:33},"NATS","A high-performance messaging system designed for cloud-native applications, enabling communication between distributed services.","Joined in June 2016","src/content/skills/en/nats.json","b85241e027888f92","en/maven",{id:356,data:358,filePath:363,digest:364},{skill:359,description:360,release:361,icon:362,feed:37,lang:33},"Maven","A project management and build tool for Java that uses a dependency model and a POM file to automate common tasks.","Joined in July 2004","maven","src/content/skills/en/maven.json","82efdcae8498984d","en/nest",{id:365,data:367,filePath:371,digest:372},{skill:368,description:369,release:370,icon:48,feed:37,lang:33},"Nest.js","A progressive Node.js framework for building scalable server-side apps.","Joined December 2017","src/content/skills/en/nest.json","fec57d21db1aeb68","en/next",{id:373,data:375,filePath:379,digest:380},{skill:376,description:377,release:378,icon:118,feed:37,lang:33},"Next.js","A React-based framework for building server-side rendered applications.","Joined May 2018","src/content/skills/en/next.json","720c7016a202131a","en/nextui",{id:381,data:383,filePath:387,digest:388},{skill:384,description:385,release:386,icon:129,feed:268,lang:33},"NextUI","A modern React UI library that provides a set of customizable and responsive components for building user interfaces.","Joined in July 2021","src/content/skills/en/nextui.json","8209dbdf2c680670","en/node",{id:389,data:391,filePath:395,digest:396},{skill:392,description:393,release:394,icon:120,feed:37,lang:33},"Node.js","A JavaScript runtime built on Chrome's V8 engine, enabling server-side execution of JavaScript.","Joined May 2009","src/content/skills/en/node.json","23e1e60b4395c4db","en/postgres",{id:397,data:399,filePath:404,digest:405},{skill:400,description:401,release:402,icon:403,feed:37,lang:33},"PostgreSQL","PostgreSQL is a powerful, open source object-relational database system.","Joined July 1996","postgres","src/content/skills/en/postgres.json","87003bb41f57fd3a","en/sass",{id:406,data:408,filePath:412,digest:413},{skill:409,description:410,release:411,icon:97,feed:268,lang:33},"SASS","A preprocessor scripting language that is interpreted or compiled into Cascading Style Sheets (CSS), adding features like variables, nested rules, and mixins.","Joined in 2006","src/content/skills/en/sass.json","f6acc54bf0b02579","en/shadcn",{id:414,data:416,filePath:420,digest:421},{skill:417,description:418,release:419,icon:80,feed:268,lang:33},"Shadcn/ui","A collection of UI components built with Radix and customized with Tailwind CSS.","Joined in January 2023","src/content/skills/en/shadcn.json","7ef8c75a3c0809d5","en/react",{id:422,data:424,filePath:427,digest:428},{skill:425,description:426,release:249,icon:73,feed:37,lang:33},"React","React is a JavaScript library for building user interfaces. It allows you to create reusable UI components and manage the state of your application.","src/content/skills/en/react.json","e3705cf98cc5e153","en/spring-boot",{id:429,data:431,filePath:436,digest:437},{skill:432,description:433,release:434,icon:435,feed:37,lang:33},"Spring Boot","A tool that simplifies Spring application setup and development by providing a fast, minimalist approach to configuration.","Joined in April 2014","spring_boot","src/content/skills/en/spring-boot.json","28c56455fe62dc26","en/spring-framework",{id:438,data:440,filePath:445,digest:446},{skill:441,description:442,release:443,icon:444,feed:37,lang:33},"Spring Framework","The core of the Spring ecosystem, providing an Inversion of Control (IoC) container and tools for building enterprise-grade Java applications.","Joined in October 2002","spring_framework","src/content/skills/en/spring-framework.json","116c70fd8d806693","en/spring-security",{id:447,data:449,filePath:454,digest:455},{skill:450,description:451,release:452,icon:453,feed:37,lang:33},"Spring Security","A framework within the Spring ecosystem for authentication and authorization, designed to secure Java applications robustly.","Joined in May 2004","spring_security","src/content/skills/en/spring-security.json","2bfc1fb096cddd89","en/tailwind",{id:456,data:458,filePath:462,digest:463},{skill:459,description:460,release:461,icon:24,feed:37,lang:33},"Tailwind","Tailwind is a utility-first CSS framework that allows you to build custom designs without writing custom CSS.","Released in 2020","src/content/skills/en/tailwind.json","d02945fd37b4e21d","en/typescript",{id:464,data:466,filePath:470,digest:471},{skill:467,description:468,release:469,icon:59,feed:37,lang:33},"Typescript","A superset of JavaScript that adds static typing, enhancing developer productivity and code quality.","Joined October 2012","src/content/skills/en/typescript.json","674121c23e2e0017","es/astro",{id:472,data:474,filePath:477,digest:478},{skill:231,description:475,release:476,icon:21,feed:37,lang:150},"Astro es un generador de sitios estáticos moderno que permite construir sitios web rápidos y de alto rendimiento utilizando tecnologías web modernas.","Lanzado en agosto de 2022","src/content/skills/es/astro.json","8d8fa2fc793697f7","es/css",{id:479,data:481,filePath:484,digest:485},{skill:239,description:482,release:483,icon:102,feed:37,lang:150},"Un lenguaje de hojas de estilo utilizado para describir la presentación de un documento escrito en HTML o XML.","Lanzado en diciembre de 1996","src/content/skills/es/css.json","5fcfc72f5ba10622","es/docker",{id:486,data:488,filePath:491,digest:492},{skill:247,description:489,release:490,icon:50,feed:37,lang:150},"Una plataforma para desarrollar, enviar y ejecutar aplicaciones en contenedores.","Lanzado en marzo de 2013","src/content/skills/es/docker.json","f7cee10cd2372ee8","es/express",{id:493,data:495,filePath:498,digest:499},{skill:255,description:496,release:497,icon:258,feed:37,lang:150},"Un framework de aplicaciones web para Node.js mínimo y flexible que proporciona un conjunto robusto de características para aplicaciones web y móviles.","Unido en noviembre de 2010","src/content/skills/es/express.json","66bd360cd7c62ce1","es/git",{id:500,data:502,filePath:505,digest:506},{skill:274,description:503,release:504,icon:277,feed:37,lang:150},"Un sistema de control de versiones distribuido que rastrea cambios en el código fuente durante el desarrollo de software.","Lanzado en 2005","src/content/skills/es/git.json","27fb6b7e0e6fb7bf","es/framermotion",{id:507,data:509,filePath:512,digest:513},{skill:264,description:510,release:511,icon:267,feed:268,lang:150},"Una biblioteca para React que permite crear animaciones suaves y de alto rendimiento en aplicaciones web.","Se unió en abril de 2018","src/content/skills/es/framermotion.json","6574cf55452a7c5e","es/graphql",{id:514,data:516,filePath:519,digest:520},{skill:283,description:517,release:518,icon:286,feed:37,lang:150},"Un lenguaje de consulta para APIs y un tiempo de ejecución para ejecutar esas consultas utilizando un sistema de tipos definido para tus datos.","Se unió en febrero de 2015","src/content/skills/es/graphql.json","a561c37d626e68cd","es/gsap",{id:521,data:523,filePath:526,digest:527},{skill:292,description:524,release:525,icon:31,feed:268,lang:150},"GSAP (GreenSock Animation Platform) es una potente librería de JavaScript para crear animaciones de alto rendimiento que funcionan en todos los navegadores principales.","Lanzado en marzo de 2008","src/content/skills/es/gsap.json","4fa3a5405149079d","es/html",{id:528,data:530,filePath:533,digest:534},{skill:300,description:531,release:532,icon:303,feed:37,lang:150},"HTML (HyperText Markup Language) es el lenguaje de marcado estándar para crear páginas web y aplicaciones web.","Se unió en octubre de 1991","src/content/skills/es/html.json","03bbfe59a3459043","es/i18n",{id:535,data:537,filePath:540,digest:541},{skill:29,description:538,release:539,icon:29,feed:268,lang:150},"Un sistema de internacionalización que permite gestionar múltiples idiomas en aplicaciones web.","Se unió en marzo de 2006","src/content/skills/es/i18n.json","8d6e12fed46dd2ff","es/java",{id:542,data:544,filePath:547,digest:548},{skill:333,description:545,release:546,icon:336,feed:37,lang:150},"Un lenguaje de programación de alto nivel, basado en clases, orientado a objetos, diseñado para tener pocas dependencias de implementación.","Se unió en enero de 1996","src/content/skills/es/java.json","9f9f1af0dfa13f51","es/mercadopago",{id:549,data:551,filePath:554,digest:555},{skill:316,description:552,release:553,icon:127,feed:268,lang:150},"Una plataforma de pago en línea que permite transacciones seguras y eficientes tanto para comerciantes como para consumidores.","Se unió en agosto de 2004","src/content/skills/es/mercadopago.json","87dcb126f28bbcac","es/maven",{id:556,data:558,filePath:561,digest:562},{skill:359,description:559,release:560,icon:362,feed:37,lang:150},"Un proyecto de gestión y construcción para Java que utiliza un modelo de dependencias y un archivo POM para automatizar tareas comunes.","Se unió en julio de 2004","src/content/skills/es/maven.json","f3d46ee5c451742d","es/nats",{id:563,data:565,filePath:568,digest:569},{skill:351,description:566,release:567,icon:57,feed:268,lang:150},"Un sistema de mensajería de alto rendimiento diseñado para aplicaciones nativas en la nube, que permite la comunicación entre servicios distribuidos.","Se unió en junio de 2016","src/content/skills/es/nats.json","77b634dc93065cf9","es/javascript",{id:570,data:572,filePath:575,digest:576},{skill:324,description:573,release:574,icon:327,feed:37,lang:150},"Un lenguaje de programación versátil que se utiliza ampliamente para el desarrollo web, tanto en el lado del cliente como en el lado del servidor.","Se unió en diciembre de 1995","src/content/skills/es/javascript.json","10853693565b6a50","es/nest",{id:577,data:579,filePath:582,digest:583},{skill:368,description:580,release:581,icon:48,feed:37,lang:150},"Un framework progresivo de Node.js para construir aplicaciones del lado del servidor escalables.","Se unió en diciembre de 2017","src/content/skills/es/nest.json","091e87d78e1b4830","es/mongodb",{id:584,data:586,filePath:589,digest:590},{skill:342,description:587,release:588,icon:345,feed:37,lang:150},"MongoDB es un programa de base de datos orientado a documentos en plataformas cruzadas. Clasificado como un programa de base de datos NoSQL, MongoDB utiliza documentos JSON-like con esquemas opcionales.","Se unió en febrero de 2009","src/content/skills/es/mongodb.json","b0d518ab19b9ae49","es/next",{id:591,data:593,filePath:596,digest:597},{skill:376,description:594,release:595,icon:118,feed:37,lang:150},"Un framework basado en React para construir aplicaciones del lado del servidor renderizadas.","Se unió en mayo de 2018","src/content/skills/es/next.json","9c59d018e87823d6","es/nextui",{id:598,data:600,filePath:603,digest:604},{skill:384,description:601,release:602,icon:129,feed:268,lang:150},"Una biblioteca de interfaces de usuario React moderna que proporciona un conjunto de componentes personalizables y responsivos para construir interfaces de usuario.","Se unió en julio de 2021","src/content/skills/es/nextui.json","fb3cd6501f8dd39c","es/node",{id:605,data:607,filePath:610,digest:611},{skill:392,description:608,release:609,icon:120,feed:37,lang:150},"Un entorno de ejecución de JavaScript construido sobre el motor V8 de Chrome, que permite la ejecución del lado del servidor de JavaScript.","Se unió en mayo de 2009","src/content/skills/es/node.json","19652ec11c26a125","es/postgres",{id:612,data:614,filePath:617,digest:618},{skill:400,description:615,release:616,icon:403,feed:37,lang:150},"PostgreSQL es un potente sistema de base de datos relacional open source.","Se unió en julio de 1996","src/content/skills/es/postgres.json","c38ac99b151fbb2d","es/react",{id:619,data:621,filePath:624,digest:625},{skill:425,description:622,release:623,icon:73,feed:37,lang:150},"React es una biblioteca de JavaScript para construir interfaces de usuario. Permite crear componentes de interfaz de usuario reutilizables y gestionar el estado de tu aplicación.","Se lanzó en 2013","src/content/skills/es/react.json","39c0cbbce90f3dcb","es/shadcn",{id:626,data:628,filePath:631,digest:632},{skill:417,description:629,release:630,icon:80,feed:268,lang:150},"Una colección de componentes de interfaz de usuario construidos con Radix y personalizados con Tailwind CSS.","Se unió en enero de 2023","src/content/skills/es/shadcn.json","24311b34270ac395","es/sass",{id:633,data:635,filePath:638,digest:639},{skill:409,description:636,release:637,icon:97,feed:268,lang:150},"SASS es un preprocesador de lenguaje de scripting que se interpreta o compila en Cascading Style Sheets (CSS), agregando características como variables, reglas anidadas y mixins.","Se unió en 2006","src/content/skills/es/sass.json","59a5fc3506c4045c","es/spring-boot",{id:640,data:642,filePath:645,digest:646},{skill:432,description:643,release:644,icon:435,feed:37,lang:150},"Spring Boot es una herramienta que simplifica la configuración y el desarrollo de aplicaciones Spring al proporcionar un enfoque rápido y minimalista.","Se unió en abril de 2014","src/content/skills/es/spring-boot.json","5745426becee541d","es/spring-framework",{id:647,data:649,filePath:652,digest:653},{skill:441,description:650,release:651,icon:444,feed:37,lang:150},"El núcleo del ecosistema Spring, que proporciona un contenedor de Inversión de Control (IoC) y herramientas para construir aplicaciones empresariales de Java de alto rendimiento.","Se unió en octubre de 2002","src/content/skills/es/spring-framework.json","52d294fa2d38e944","es/spring-security",{id:654,data:656,filePath:659,digest:660},{skill:450,description:657,release:658,icon:453,feed:37,lang:150},"Un framework dentro del ecosistema Spring para autenticación y autorización, diseñado para proteger aplicaciones Java de manera robusta.","Se unió en mayo de 2004","src/content/skills/es/spring-security.json","03c9665f7cf40b71","es/tailwind",{id:661,data:663,filePath:666,digest:667},{skill:459,description:664,release:665,icon:24,feed:37,lang:150},"Tailwind es un framework de CSS de utilidad primero que te permite construir diseños personalizados sin escribir CSS personalizado.","Se lanzó en 2020","src/content/skills/es/tailwind.json","3720b331bb19a09a","es/typescript",{id:668,data:670,filePath:673,digest:674},{skill:467,description:671,release:672,icon:59,feed:37,lang:150},"Typescript es un superconjunto de JavaScript que agrega tipado estático, mejorando la productividad y la calidad del código de los desarrolladores.","Se unió en octubre de 2012","src/content/skills/es/typescript.json","cc8fb3c34464266c","experience",["Map",677,678,699,700,720,721,738,739],"en/devtion",{id:677,data:679,filePath:697,digest:698},{dates:680,title:683,location:684,summary:685,responsibilities:686,achievements:690,company:694,lang:33},{start:681,end:682},"Jul 2022","Feb 2023","Junior Full Stack Developer","Buenos Aires, Argentina - Remote","Developed and maintained web applications using React.js. Collaborated with the team to implement new features and fix bugs. Strengthened my React skills by working on large team projects.",[687,688,689],"Developed and maintained interactive user interfaces using React.js.","Collaborated with designers to translate user designs into functional and styled code.","Implemented agile development practices to improve team efficiency and the quality of the final product.",[691,692,693],"Contributed to several major projects, enhancing the functionality and usability of applications.","Implemented efficient solutions that optimized application performance, resulting in faster load times.","Received recognition from the team for my problem-solving ability and commitment to code quality.",{name:695,url:696},"DevtionIT","https://devtionit.com","src/content/experiences/en/devtion.json","35e5db02d4e41532","en/freelance",{id:699,data:701,filePath:718,digest:719},{dates:702,title:705,location:706,summary:707,responsibilities:708,achievements:713,company:717,lang:33},{start:703,end:704},"Feb 2024","Present","Full Stack Developer Freelance","Rio Negro, Argentina - Remote","Experienced Full Stack Developer working freelance, creating personalized web solutions for various clients. I specialize in the complete development cycle, from UI/UX design to backend implementation and third-party service integration.",[709,710,711,712],"Conceive, design, and develop complete web applications, covering both frontend and backend.","Collaborate closely with clients to transform their ideas into functional and scalable solutions.","Implement clean and maintainable architectures to ensure the longevity and ease of future project expansions.","Ensure the security and reliability of applications, protecting user data and transactions.",[714,715,716],"Significantly improved user experience and application performance, achieving a 30% reduction in page load times on key projects.","Successfully integrated various third-party APIs and external services, such as payment gateways, expanding platform functionalities and automating processes.","Applied best development practices to ensure robust, efficient, and easily scalable code.",null,"src/content/experiences/en/freelance.json","94cc5ca0ac7a1b6d","es/freelance",{id:720,data:722,filePath:736,digest:737},{dates:723,title:724,location:725,summary:726,responsibilities:727,achievements:732,company:717,lang:150},{start:703,end:704},"Desarrollador Full Stack Freelance","Rio Negro, Argentina - Remoto","Experiencia como desarrollador Full Stack freelance, creando soluciones web personalizadas para diversos clientes. Especializado en el ciclo completo de desarrollo, desde el diseño de la interfaz hasta la implementación del backend y la integración de servicios de terceros.",[728,729,730,731],"Concebir, diseñar y desarrollar aplicaciones web completas, abarcando tanto el frontend como el backend.","Colaborar estrechamente con clientes para transformar sus ideas en soluciones funcionales y escalables.","Implementar arquitecturas limpias y mantenibles que aseguren la longevidad y la facilidad de futuras expansiones de los proyectos.","Garantizar la seguridad y la fiabilidad de las aplicaciones, protegiendo los datos de los usuarios y las transacciones.",[733,734,735],"Mejoré significativamente la experiencia del usuario y el rendimiento de las aplicaciones, como la reducción del 30% en los tiempos de carga en proyectos clave.","Integré exitosamente diversas APIs y servicios externos, ampliando las funcionalidades de las plataformas y automatizando procesos.","Apliqué mejores prácticas de desarrollo para asegurar un código robusto, eficiente y de fácil escalabilidad.","src/content/experiences/es/freelance.json","408a62641e908616","es/devtion",{id:738,data:740,filePath:754,digest:755},{dates:741,title:742,location:743,summary:744,responsibilities:745,achievements:749,company:753,lang:150},{start:681,end:682},"Desarrollador Full Stack Jr.","Buenos Aires, Argentina - Remoto","Desarrollo y mantenimiento de aplicaciones web utilizando React.js. Colaboré con el equipo para implementar nuevas funciones y corregir errores. Fortalecí mis habilidades en React al trabajar en grandes proyectos en equipo.",[746,747,748],"Desarrollé y mantuve interfaces de usuario interactivas utilizando React.js.","Colaboré con diseñadores para traducir diseños de usuario en código funcional y estilizado.","Implementé prácticas de desarrollo ágil para mejorar la eficiencia del equipo y la calidad del producto final.",[750,751,752],"Contribuí a varios proyectos importantes, mejorando la funcionalidad y la usabilidad de las aplicaciones.","Implementé soluciones eficientes que optimizaron el rendimiento de la aplicación, resultando en tiempos de carga más rápidos.","Recibí reconocimiento del equipo por mi capacidad para resolver problemas y mi compromiso con la calidad del código.",{name:695,url:696},"src/content/experiences/es/devtion.json","4efb4accc4d490b4","university",["Map",758,759,769,770],"en/engineering",{id:758,data:760,filePath:767,digest:768},{dates:761,title:764,universityName:765,link:766,lang:33},{start:762,end:763},"2017","2021","Electronic Engineering","Universidad Nacional de Rio Negro","https://www.unrn.edu.ar/carreras/Ingenieria-Electronica-5","src/content/university/en/engineering.json","c7d2f89f99715545","es/engineering",{id:769,data:771,filePath:774,digest:775},{dates:772,title:773,universityName:765,link:766,lang:150},{start:762,end:763},"Ingeniería Electrónica","src/content/university/es/engineering.json","bbca2ef32dba3ef8","certification",["Map",321,778,785,786,794,795,802,803,810,811,817,818,825,826,438,832,838,839,845,846,853,854,570,858,862,863,867,868,872,873,877,878,882,883,647,887,891,892,896,897],{id:321,data:779,filePath:783,digest:784},{date:763,institute:780,certificationName:781,link:782,lang:33},"CoderHouse","Javascript","https://www.coderhouse.com/ar/online/javascript","src/content/certifications/en/javascript.json","978a8c48d312c5c7","en/nest-backend",{id:785,data:787,filePath:792,digest:793},{date:788,institute:789,certificationName:790,link:791,lang:33},"2023","Udemy","Nest: Desarrollo de backend escalable con Node.","https://www.udemy.com/course/nest-framework/","src/content/certifications/en/nest-backend.json","33c7d37112982495","en/nest-graphql",{id:794,data:796,filePath:800,digest:801},{date:797,institute:789,certificationName:798,link:799,lang:33},"2024","Nest + GraphQL: Evoluciona tus APIs.","https://www.udemy.com/course/nest-graphql/","src/content/certifications/en/nest-graphql.json","80cd8850cd35292d","en/next-microservices",{id:802,data:804,filePath:808,digest:809},{date:797,institute:805,certificationName:806,link:807,lang:33},"Devtalles","NestJS + Microservicios: Aplicaciones escalables y modulares.","https://cursos.devtalles.com/courses/nestjs-microservicios","src/content/certifications/en/next-microservices.json","f1d7fac4dc4f1bcf","en/nextjs",{id:810,data:812,filePath:815,digest:816},{date:797,institute:805,certificationName:813,link:814,lang:33},"Next.js: El framework de React para producción.","https://cursos.devtalles.com/courses/nextjs","src/content/certifications/en/nextjs.json","b4bea3c3b7f90496","en/reactjs",{id:817,data:819,filePath:823,digest:824},{date:820,institute:780,certificationName:821,link:822,lang:33},"2022","React.js","https://www.coderhouse.com/ar/online/reactjs","src/content/certifications/en/reactjs.json","0f9434906ba06bc5","en/nodejs",{id:825,data:827,filePath:830,digest:831},{date:788,institute:789,certificationName:828,link:829,lang:33},"Complete NodeJS Developer in 2023 (GraphQL, MongoDB, + more).","https://www.udemy.com/course/complete-nodejs-developer-zero-to-mastery/","src/content/certifications/en/nodejs.json","a614c91d8191cb00",{id:438,data:833,filePath:836,digest:837},{date:797,institute:789,certificationName:834,link:835,lang:33},"Spring Framework 6 & Spring Boot 3 desde cero a experto","https://www.udemy.com/course/spring-framework-5","src/content/certifications/en/spring-framework.json","27dd4f885bf42550","en/web-developer",{id:838,data:840,filePath:843,digest:844},{date:763,institute:780,certificationName:841,link:842,lang:33},"Desarrollo Web","https://www.coderhouse.com/ar/online/desarrollo-web-online","src/content/certifications/en/web-developer.json","b6c5a94de202f1cd","en/web-accesibility",{id:845,data:847,filePath:851,digest:852},{date:788,institute:848,certificationName:849,link:850,lang:33},"Platzi","Accesibilidad web.","https://platzi.com/cursos/accesibilidad-web","src/content/certifications/en/web-accesibility.json","7e2ab13469c68219","es/nest-backend",{id:853,data:855,filePath:856,digest:857},{date:788,institute:789,certificationName:790,link:791,lang:150},"src/content/certifications/es/nest-backend.json","a92f7b58a5f13612",{id:570,data:859,filePath:860,digest:861},{date:763,institute:780,certificationName:781,link:782,lang:150},"src/content/certifications/es/javascript.json","6c995f0ac0194fde","es/nest-graphql",{id:862,data:864,filePath:865,digest:866},{date:797,institute:789,certificationName:798,link:799,lang:150},"src/content/certifications/es/nest-graphql.json","14a1ff0a7be4913b","es/next-microservices",{id:867,data:869,filePath:870,digest:871},{date:797,institute:805,certificationName:806,link:807,lang:150},"src/content/certifications/es/next-microservices.json","fa3b52610abf2b0b","es/nextjs",{id:872,data:874,filePath:875,digest:876},{date:797,institute:805,certificationName:813,link:814,lang:150},"src/content/certifications/es/nextjs.json","e856b5ec74b99dbf","es/nodejs",{id:877,data:879,filePath:880,digest:881},{date:788,institute:789,certificationName:828,link:829,lang:150},"src/content/certifications/es/nodejs.json","949753183987dfbe","es/reactjs",{id:882,data:884,filePath:885,digest:886},{date:820,institute:780,certificationName:821,link:822,lang:150},"src/content/certifications/es/reactjs.json","43a6ac89092ff427",{id:647,data:888,filePath:889,digest:890},{date:797,institute:789,certificationName:834,link:835,lang:150},"src/content/certifications/es/spring-framework.json","68a4095129b28450","es/web-accesibility",{id:891,data:893,filePath:894,digest:895},{date:788,institute:848,certificationName:849,link:850,lang:150},"src/content/certifications/es/web-accesibility.json","496cf9d28e53aac7","es/web-developer",{id:896,data:898,filePath:899,digest:900},{date:763,institute:780,certificationName:841,link:842,lang:150},"src/content/certifications/es/web-developer.json","5bc99912481a6b4d","blog",["Map",903,904,915,916,926,927,936,937,946,947,956,957],"en/migration-from-next-to-astro",{id:903,data:905,body:912,filePath:913,digest:914,deferredRender:37},{title:906,description:907,date:908,tags:909,lang:33},"Migrating from Next.js to Astro","Why I switched from Next.js to Astro and how it made maintaining and updating my site much easier.",["Date","2025-10-21T03:00:00.000Z"],[910,911],"article","news","For a long time, I used **Next.js** for my personal site and blog. I’ve always liked working with **React**, so Next felt like the natural choice.  \r\nBut over time, I started to notice something: maintaining a static site with Next.js was way more complicated than it needed to be.\r\n\r\nEvery time I wanted to add a new post or update some information, I had to touch the code, rebuild everything, and wait. Since I don’t use a CMS or database, all my content is static — and in theory, that should be simple… but with Next, it just wasn’t.\r\n\r\n---\r\n\r\n## Next.js is great, but not for everything\r\n\r\nNo doubt about it: Next.js is a powerful framework.  \r\nIf you’re building a complex app, an admin dashboard, or something that needs SSR, API routes, and authentication, it’s amazing.\r\n\r\nThe issue comes when your project **doesn’t need all that**.  \r\nA simple blog, portfolio, or static site ends up carrying way more weight than it should.\r\n\r\nSome things that frustrated me:\r\n\r\n- The **bundle size** was large even for simple pages.\r\n- Adding content required setting up **contentlayer** or other extra tools.\r\n- Each new post meant changing routes or rebuilding everything.\r\n- The setup felt heavier and heavier over time.\r\n\r\nAt some point, it feels like you’re using a **jackhammer to hang a picture frame**.\r\n\r\n---\r\n\r\n## Then I found Astro\r\n\r\nOne day, almost by accident, I started experimenting with **Astro**, and it completely changed my workflow.\r\n\r\nThe first thing that struck me was **how simple it is to build things**.  \r\nAstro follows a _“content-first”_ philosophy — it’s designed for sites that prioritize content, not apps.\r\n\r\nI was able to create a fully functional blog in minutes, without installing any extra dependencies.  \r\nNo need to set up contentlayer or routing. You just create a Markdown file in `src/content`, and Astro handles the rest: it generates routes, provides type safety, and even validates metadata automatically.\r\n\r\nAnd the **performance is incredible**. Astro ships zero JavaScript by default and only loads it when you ask for it, which means blazing-fast pages and super lightweight output.\r\n\r\n---\r\n\r\n## Still using React (but as an island)\r\n\r\nThe best part is I didn’t have to abandon React.  \r\nAstro lets me use it **only when I really need it**, as an isolated “island” within the page.\r\n\r\nFor example, if I need an interactive component or a small visual effect, I can use my usual React components — hooks, props, everything — without affecting the performance of the rest of the site.\r\n\r\nI didn’t have to rewrite anything in plain TypeScript or change how I think about components.  \r\nAstro just gives me the freedom to choose **when and where** to use React.\r\n\r\n---\r\n\r\n## Comparing the experience\r\n\r\n| Aspect             | Next.js                              | Astro                          |\r\n| ------------------ | ------------------------------------ | ------------------------------ |\r\n| Bundle size        | Large, even for simple sites         | Minimal by default             |\r\n| Content management | Needs contentlayer or external tools | Built-in `content collections` |\r\n| Learning curve     | Steeper for static sites             | Very low                       |\r\n| Performance        | Good, but heavier with JS            | Excellent, 0 JS by default     |\r\n| React              | Fully dependent                      | Optional, as needed            |\r\n\r\n---\r\n\r\n## My current workflow\r\n\r\nThese days, writing a new blog post is literally **just creating a Markdown file**.  \r\nAstro takes care of everything else — routing, layouts, type checking, and rendering.\r\n\r\nI use **TailwindCSS** for styling and **React** for interactive components (like menus or hover effects).  \r\nEverything else is static, clean, and fast.\r\n\r\nI no longer worry about bundle size or unnecessary dependencies.  \r\nI just write and publish.\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nMigrating to Astro made my life a lot easier.  \r\nNow, whenever I want to **add new information or update something**, I can do it effortlessly — no extra tools, no complex setup.\r\n\r\nWith Next, even changing something small like a piece of text or a section felt like too many steps.  \r\nWith Astro, everything is more direct: open a file, change it, done.\r\n\r\nIt wasn’t just a change in technology, but a **change in workflow**.  \r\nMaintaining my site is now faster, lighter, and much more practical.","src/content/blog/en/migration-from-next-to-astro.mdx","1d071f070055c26d","en/nest-vs-spring",{id:915,data:917,body:923,filePath:924,digest:925,deferredRender:37},{title:918,description:919,date:920,tags:921,lang:33},"Nest.js vs Spring: Backend Framework Comparison","Backend development offers a wide variety of frameworks to create robust, scalable, and efficient web applications. Two of the most prominent options are Nest.js and Spring. In this article, we will explore their differences and similarities in key aspects such as architecture, ecosystem, language, ease of use and performance.",["Date","2024-12-29T03:00:00.000Z"],[910,922],"update","## Architecture\r\n\r\nThe architecture of a framework defines how applications are structured and organized, which significantly impacts scalability, maintainability, and flexibility. Choosing the right architectural approach is crucial to meet the specific needs of your application.\r\n\r\n### Spring Framework\r\n\r\nSpring is a mature and versatile framework based on patterns like **MVC (Model-View-Controller)**. Its core is the **Inversion of Control (IoC)** container, which manages the dependencies of applications. It provides flexibility to build both monolithic applications and microservices-based applications, thanks to tools like **Spring Boot**, which simplifies initial configuration.\r\n\r\n### Nest.js\r\n\r\nNest.js adopts a modular architecture inspired by Angular, where decorators and classes play a key role. This modular approach makes it easy to organize code into independent modules, which is ideal for scalable and microservices-based projects. Compared to other modern frameworks like **Express** or **Fastify**, Nest.js stands out for offering a clearer and more robust structure, reducing configuration effort and enabling more organized development from the start. It also includes native support for dependency injection patterns.\r\n\r\n### Comparison\r\n\r\n- **Nest.js** offers a more modern and modular design from the start.  \r\n- **Spring** is more mature and flexible, allowing both traditional and modern architectures.\r\n\r\n\r\n## Spring Ecosystem\r\n\r\nThe Spring ecosystem is vast and proven, with tools like:\r\n\r\n- **Spring Boot:** Simplifies configuration and deployment of applications.  \r\n- **Spring Data:** Facilitates interaction with databases.  \r\n- **Spring Security:** Provides a robust system for authentication and authorization management.  \r\n- **Spring Web:** Offers a complete set of tools to develop web applications.  \r\n\r\nIts community is one of the largest in the backend development world, offering commercial support and extensive documentation.\r\n\r\n\r\n## Nest.js Ecosystem\r\n\r\nAlthough younger, Nest.js has a rapidly growing ecosystem. It offers modern integrations for:\r\n\r\n- **Databases:** TypeORM, Prisma, Mongoose.  \r\n- **Advanced APIs:** GraphQL, WebSockets.  \r\n- **Microservices:** Tools to create and manage distributed services.  \r\n\r\nNest.js' community is active and constantly expanding, though it does not yet match the size of Spring's community.\r\n\r\n\r\n## Programming Language: Java vs TypeScript\r\n\r\nSpring is based on **Java**, a robust and widely used language in enterprise environments. It is also compatible with other languages like **Kotlin** and **Groovy**, offering some flexibility.\r\n\r\nNest.js is written in **TypeScript**, a superset of **JavaScript** with static typing. This makes it particularly attractive for developers coming from the frontend or those looking for a modern language for agile projects.\r\n\r\n### Comparison: Java or TypeScript\r\n\r\n- **Java** excels in critical enterprise applications, offering a solid foundation for large-scale, long-term projects.  \r\n- **TypeScript** presents itself as the modern option for agile teams that prefer to work with frontend technologies and want to leverage static typing to improve code quality and productivity.\r\n\r\n\r\n## Ease of Use\r\n\r\n- **Spring** has a steep learning curve due to its flexibility and power. However, **Spring Boot** significantly simplifies the initial configuration, enabling the creation of production-ready applications in no time.  \r\n- **Nest.js** is more intuitive and beginner-friendly, especially for those familiar with TypeScript. Its modular structure and code generators make development easier.\r\n\r\n\r\n## Performance\r\n\r\nPerformance is a critical factor in backend development and should be evaluated in terms of CPU consumption, memory usage, and the overall impact on development costs.\r\n\r\n### CPU\r\n\r\n- **Nest.js:** Built on Node.js, it uses a single-threaded event loop model. This makes it highly efficient for I/O-intensive applications. Some benchmarks show up to **20% less CPU usage** in such cases compared to multi-threaded models.  \r\n- **Spring Framework:** Built on Java, it uses a multi-threaded model. This makes it more efficient for CPU-intensive tasks, offering up to **30% better performance** in such scenarios.\r\n\r\n### Memory\r\n\r\n- **Nest.js:** Thanks to its modular and minimalist design, it can reduce memory usage by up to **40%** in applications similar to those built in Spring Framework.  \r\n- **Spring Framework:** Consumes more memory due to its wide set of features. A typical enterprise application may require **200–300 MB** more memory than its equivalent in Nest.js.\r\n\r\n### Development Costs\r\n\r\n- **Nest.js:** Its base in JavaScript, a language known by **67.7% of developers**, can shorten the learning curve and reduce development costs if the team is already proficient in JavaScript.  \r\n- **Spring Framework:** It may require specialized knowledge of Java, which could increase training costs if the team lacks prior experience.\r\n\r\n\r\n## Conclusions\r\n\r\nHow to choose between Nest.js and Spring Framework? It largely depends on the specific needs of your project and the experience of your development team.\r\n\r\n**Nest.js**, based on modern JavaScript, is an accessible option for teams already proficient in JavaScript. Its leaner architecture and potentially lower memory footprint may result in reduced resource consumption and faster development times. Additionally, its single-threaded event loop model is perfect for I/O-intensive applications.\r\n\r\nOn the other hand, **Spring Framework** stands out for its robust feature set and multi-threaded model, ideal for more complex and CPU-intensive tasks. While memory usage may be higher and development costs may be higher for Java, the wide functionality Spring offers is a worthwhile trade-off for certain projects.\r\n\r\nThe key to choosing between these frameworks is to fully understand the project requirements and carefully evaluate the pros and cons of each. With this information, you can ensure the success of your project.","src/content/blog/en/nest-vs-spring.mdx","ac659b6d3da3b7f7","en/working-with-react-useeffect-hook",{id:926,data:928,body:933,filePath:934,digest:935,deferredRender:37},{title:929,description:930,date:931,tags:932,lang:33},"Rendering and Re-Rendering in React","In this article, you will learn what happens behind a 're-render' in React, what causes them, how to avoid them, and patterns to consider for optimizing our applications.",["Date","2024-11-06T03:00:00.000Z"],[910,922],"## Introduction\r\n\r\nUnderstanding the key concepts of a library is essential to feel comfortable working with it. That's why I decided to write this article about the cornerstone that gave rise to React: 'renders'. Although React has evolved significantly in recent months, its essence remains intact: creating component-based interfaces that return JSX.\r\n\r\nMastering the process of 'rendering' and the events that trigger it is crucial for designing efficient applications and building a solid foundation for continued improvement. At the end of the day, working with React always leads us to discuss 'renders', so why not understand them thoroughly from the start?\r\n\r\n## What is a 'Render' in React\r\n\r\nLet's start by understanding what 'render' means in React. Essentially, a 'render' is the process by which React sends the JSX returned by a component to the DOM. This JSX is calculated from three key elements:\r\n\r\n- The properties (props) that the component receives.\r\n- The component's internal state.\r\n- The values of the contexts that the component consumes through the Context API.\r\n\r\nA component is rendered whenever it is part of the component tree we have defined.\r\n\r\n![Component Tree](https://res.cloudinary.com/dhu8pktj2/image/upload/v1733336511/blog/render%20and%20rerender/tmo1gem70yyqaffag77k.png)\r\n\r\nWhen the browser loads our application for the first time, React generates a component tree. Each component returns pieces of JSX that, when combined, define the complete structure of the interface. However, this structure is not static. As the user interacts with the application, the component tree can change in various ways:\r\n\r\n- Adding new components.\r\n- Removing existing components.\r\n- Modifying the state or props of already present components.\r\n\r\nThe key moment in this process is the 'initial render', which occurs when a component first appears in the tree. During this first render, the component sets the initial values of its state.\r\n\r\nFrom there, we enter the realm of 'rerenders', where things get really interesting.\r\n\r\n## What are 'Re-renders'\r\n\r\nA 're-render' is any rendering of a component that is already in the DOM and does not correspond to the 'initial render'.\r\n\r\nRe-renders occur when there is a change in the application state, caused by:\r\n\r\n- User actions, such as interacting with an element of the interface.\r\n- External updates, such as the arrival of data from an API via a fetch call.\r\n\r\n### Types of 'Re-renders'\r\n\r\nWe can classify re-renders into two main categories:\r\n\r\n- **Necessary re-renders**: These are renders where the component is directly affected by a change, and its new JSX will differ from the previous one. Example: In a counter, when the user presses the button to increment it, the component needs a new render to display the updated value.\r\n- **Unnecessary re-renders**: These occur when a component re-renders even if it has not been affected by the change and generates the same JSX as in the previous render.\r\n\r\nCommon cause: An inefficient structure or poor planning of our application.\r\n\r\nUnnecessary re-renders can affect the performance of the application, so identifying and avoiding them is key to maintaining a smooth user experience.\r\n\r\n## Reasons a Component Re-renders\r\n\r\nA component can re-render for one of the following reasons:\r\n\r\n- Change in internal state (declared using useState), usually as a result of a user action, such as clicking a button.\r\n- Change in context, if the component is consuming a context and its value is updated.\r\n- Re-render of the parent component, which causes, by default, all child components to re-render.\r\n\r\nLet's take a closer look at these:\r\n\r\n### Changes in State\r\n\r\nWhen we declare a piece of state within a component using the useState hook, any change in that state, triggered by invoking setState, will cause a re-render of the component.\r\n\r\n```javascript\r\nexport const Counter = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n> **Note:** Each time the state is updated with setCount, the component is rendered again.\r\n\r\n### Change in Context\r\n\r\nWhen the value of a context changes, all components that are consuming that context via the useContext hook will re-render to ensure the view reflects the update.\r\n\r\n```javascript\r\nconst ContContext = createContext(0);\r\n\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <ContContext.Provider value={count}>\r\n      <Counter />\r\n    </ContContext.Provider>\r\n  );\r\n}\r\n```\r\n\r\n> **Note:** When the count state changes, the context in the Provider receives a new value. As a result, all components using useContext(ContContext) detect this change and automatically re-render.\r\n\r\n### Re-rendering the Parent Component\r\n\r\nBy default, a child component will re-render whenever its parent component does. In other words, when a component re-renders, all of its child components also re-render, even if there are no direct changes to them.\r\n\r\n```javascript\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Component />\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Component() {\r\n ...\r\n}\r\n```\r\n\r\n> **Note:** In this case, the Component component re-renders every time the App component does.\r\n\r\n## How to Prevent Unnecessary Re-renders\r\n\r\nNow that we know the reasons a component can render, let's explore some techniques that will help us prevent unnecessary re-renders and optimize the performance of our applications.\r\n\r\n### Place State as Low as Possible\r\n\r\nThis technique is useful when working with complex components that manage multiple states, especially if some of them are only used in specific parts of the component tree.\r\n\r\n![Component Tree with State](https://res.cloudinary.com/dhu8pktj2/image/upload/v1733499382/blog/render%20and%20rerender/gbarvy0hgjckm8iuv7mo.png)\r\n\r\nFor example, if stateFour is only relevant for ComponentFour, keeping it at a higher level will cause any change in this state to trigger a render of the entire tree (remember: rendering a parent component also re-renders all its children). This can be inefficient.\r\n\r\nTo avoid this issue, we can define stateFour directly in ComponentFour, limiting its impact and ensuring changes only affect the component that truly needs it.\r\n\r\n![Component Tree with Modified State](https://res.cloudinary.com/dhu8pktj2/image/upload/v1733499408/blog/render%20and%20rerender/u2wjqegjlv0n7sk6axeu.png)\r\n\r\n### Pass Components as Props\r\n\r\nThis technique is especially useful when working with expensive-to-render components that are contained within a component that renders frequently, such as a form managing inputs.\r\n\r\n```javascript\r\nconst FormComponent = () => {\r\n  // Component logic and state\r\n\r\n  return (\r\n    <div>\r\n      <input type=\"text\" placeholder=\"Input 1\" />\r\n      <input type=\"text\" placeholder=\"Input 2\" />\r\n      <SlowComponent />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nEvery time FormComponent renders, the inputs and SlowComponent also re-render, which can negatively affect performance.\r\n\r\nTo avoid this problem, we can pass the expensive component as a prop, for example, using children. This works because children is just a reference to the component, and React does not re-render it unless it explicitly changes. It's as if the component is already 'pre-rendered'.\r\n\r\n```javascript\r\nconst ParentComponent = () => {\r\n  return (\r\n    <FormComponent>\r\n      <SlowComponent />\r\n    </FormComponent>\r\n  );\r\n};\r\n\r\nconst FormComponent = ({ children }) => {\r\n  return (\r\n    <div>\r\n      <input type=\"text\" placeholder=\"Input 1\" />\r\n      <input type=\"text\" placeholder=\"Input 2\" />\r\n      {children}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nThis technique, known as 'wrapping state around children', is very useful for optimizing similar cases.\r\n\r\n> **Note:** This approach is not limited to the children prop: we can define any number of props in a component and use this pattern to prevent unnecessary renders.\r\n\r\n### Avoid Creating Components Inside Others\r\n\r\nIt is important to avoid an anti-pattern that can cause significant performance issues: defining a component inside another.\r\n\r\n```javascript\r\nfunction SomeComponent() {\r\n  const OtherComponent = () => {\r\n    const [state, setState] = useState();\r\n    useEffect(() => {\r\n      // Effect logic\r\n    }, []);\r\n\r\n    return <div>Component content</div>;\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <OtherComponent />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\nThis code includes the OtherComponent component defined inside SomeComponent, which is an anti-pattern in React because it causes OtherComponent to re-mount and execute all its effects every time SomeComponent renders. This can be inefficient and lead to performance problems.\r\n\r\n## Memoize components with React.memo\r\n\r\nReact's memo function allows us to optimize functional components by wrapping them to avoid unnecessary renders. If the component's props haven't changed since the previous render, React reuses the previous result, improving performance. For those who have worked with class components, memo behaves similarly to the shouldComponentUpdate function, which allowed you to decide if a component should update. Let's see how to use memo with some practical examples.\r\n\r\n### Component without properties\r\n\r\nIn this case, the component we are wrapping with React.memo does not receive any props. As a result, this component will not re-render even when the parent component renders, as it doesn't depend on external data.\r\n\r\nThis makes the optimization even simpler, as we don't need to check if the props have changed since there are no props to check.\r\n\r\n```javascript\r\nconst NoPropsComponent = React.memo(() => {\r\n  console.log(\"Rendering NoPropsComponent\");\r\n  return <div>This component has no props</div>;\r\n});\r\n\r\nconst ParentComponent = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\r\n        Increment\r\n      </button>\r\n      <NoPropsComponent />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n> **Note:** In this example, every time ParentComponent renders (e.g., when count is incremented), NoPropsComponent does not re-render since it has no props and its rendering does not depend on any change in the parent component's state.\r\n\r\n### Component with properties\r\n\r\nWhen a memoized component with React.memo receives props, it will only re-render if one of those props changes. If the props don't change between renders, React will avoid unnecessary re-renders, which can improve performance.\r\n\r\n```javascript\r\nconst ExpensiveComponent = React.memo(({ value }) => {\r\n  console.log(\"Rendering ExpensiveComponent\");\r\n  return <div>The value is: {value}</div>;\r\n});\r\n\r\nconst ParentComponent = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [value, setValue] = useState(\"initial value\");\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\r\n        Increment\r\n      </button>\r\n      <button\r\n        onClick={() =>\r\n          setValue((prevValue) =>\r\n            prevValue === \"initial value\" ? \"new value\" : \"initial value\"\r\n          )\r\n        }\r\n      >\r\n        Change value\r\n      </button>\r\n      <ExpensiveComponent value={value} />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n> **Note:** In this example, ExpensiveComponent will only re-render if the value of `value` changes. Even if the `count` state in ParentComponent changes (when the first button is clicked), ExpensiveComponent will not re-render if `value` does not change.\r\n\r\n### Combine useMemo / useCallback with memo\r\n\r\nIn React, `memo` is a powerful tool to avoid unnecessary renders of a component, but what happens when the component's props are functions, objects, or arrays? In these cases, `memo` won't work as expected unless we use the appropriate hooks. Let's see how we can improve this.\r\n\r\nWhen we pass functions or objects as props to a memoized component, if those values change on every render, memoization won't take effect. This is because React treats the new functions or objects as different values, even if the content is the same. Let's see this in some examples.\r\n\r\n```javascript\r\nimport { memo } from \"react\";\r\n\r\nconst Child = ({ onClick }) => <button onClick={onClick}>Click me</button>;\r\n\r\nconst MemorizedChild = memo(Child);\r\n\r\nconst Parent = () => {\r\n  const handleClick = () => console.log(\"Clicked!\");\r\n\r\n  return (\r\n    <div>\r\n      <MemorizedChild onClick={handleClick} />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nIn this example, the `Parent` component creates a new `handleClick` function on every render. Although the function logic is the same, React creates a new reference every time, which causes `MemorizedChild` to receive a new value for `onClick` and re-render unnecessarily.\r\n\r\nAnother common case is when we pass an object as a prop. Let's see the following example.\r\n\r\n```javascript\r\nimport { memo } from \"react\";\r\n\r\nconst Child = ({ pet }) => <div>{pet.name}</div>;\r\n\r\nconst MemorizedChild = memo(Child);\r\n\r\nconst Parent = () => {\r\n  const pet = { name: \"Fido\" };\r\n\r\n  return (\r\n    <div>\r\n      <MemorizedChild pet={pet} />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nIn this case, `Parent` creates a new `pet` object on every render. Although the object's content doesn't change, its reference does, causing `MemorizedChild` to receive a new object on every render and re-render unnecessarily.\r\n\r\nFortunately, React provides the `useMemo` and `useCallback` hooks to prevent creating new instances of objects and functions on every render. Let's see how we can improve these examples.\r\n\r\nThe `useMemo` hook memoizes a calculated value between renders and only recalculates it if its dependencies change. It takes two parameters:\r\n\r\n1. A function that returns the value to be memoized.\r\n2. An array of dependencies, similar to the `useEffect` hook. The function will only execute if the dependencies change.\r\n\r\nOn the other hand, `useCallback` memoizes functions in the same way. It takes two parameters:\r\n\r\n1. The function to be memoized.\r\n2. An array of dependencies. If any of the dependencies change, the function is recalculated; otherwise, the same instance is reused.\r\n\r\n```javascript\r\nimport { useMemo, useCallback } from \"react\";\r\n\r\nconst ParentComponent = ({ name }) => {\r\n  const pet = useMemo(() => ({ name }), [name]);\r\n\r\n  const logName = useCallback(() => {\r\n    console.log(name);\r\n  }, [name]);\r\n\r\n  return <div>...</div>;\r\n};\r\n```\r\n\r\nWith this, the previous examples can be improved to avoid unnecessary renders. Let's see how to apply `useMemo` and `useCallback` to improve the examples.\r\n\r\nFor the `onClick` function case, we can memoize it with `useCallback`, ensuring that its reference never changes between renders.\r\n\r\n```javascript\r\nimport { memo, useCallback } from \"react\";\r\n\r\nconst Child = ({ onClick }) => <button onClick={onClick}>Press</button>;\r\n\r\nconst MemorizedChild = memo(Child);\r\n\r\nconst Parent = () => {\r\n  const handleClick = useCallback(() => {\r\n    console.log(\"Clicked\");\r\n  }, []);\r\n\r\n  return <MemorizedChild onClick={handleClick} />;\r\n};\r\n```\r\n\r\nNow, even if `Parent` re-renders, `handleClick` will not be recreated because `useCallback` memoizes the function.\r\n\r\n## Conclusions\r\n\r\nWith this article, we have covered various React techniques to avoid unnecessary renders, which can significantly improve the performance of your applications.\r\n\r\nMy advice is to first familiarize yourself with the different causes that can trigger a re-render and learn to identify which components are susceptible to optimization. With the approaches I have explained, you will be able to make your application more efficient while also gaining a better understanding of how React's rendering system works.\r\n\r\nMastering these techniques will not only allow you to write more efficient code but also deepen your understanding of how React handles UI updates and rendering, which is key to building fast, high-performance applications.","src/content/blog/en/working-with-react-useeffect-hook.mdx","4adfea2457399758","es/nest-vs-spring",{id:936,data:938,body:943,filePath:944,digest:945,deferredRender:37},{title:939,description:940,date:941,tags:942,lang:150},"Nest.js vs Spring: Comparativa de Frameworks para Backend","El desarrollo backend ofrece una gran variedad de frameworks para crear aplicaciones web robustas, escalables y eficientes. Dos de las opciones son Nest.js y Spring. En este artículo, exploraremos sus diferencias y similitudes en aspectos clave como arquitectura, ecosistema, idioma, facilidad de uso y rendimiento.",["Date","2024-12-29T03:00:00.000Z"],[910,922],"## Arquitectura\r\n\r\nLa arquitectura de un framework define cómo se estructuran y organizan las aplicaciones, lo que impacta significativamente en su escalabilidad, mantenibilidad y flexibilidad. Elegir el enfoque arquitectónico adecuado es crucial para satisfacer las necesidades específicas de tu aplicación.\r\n\r\n### Spring Framework\r\n\r\nSpring es un framework maduro y versátil basado en patrones como **MVC (Modelo-Vista-Controlador)**. Su núcleo es el contenedor de **Inversión de Control (IoC)**, que gestiona las dependencias de las aplicaciones. Ofrece flexibilidad para construir tanto aplicaciones monolíticas como aplicaciones basadas en microservicios, gracias a herramientas como **Spring Boot**, que simplifica la configuración inicial.\r\n\r\n### Nest.js\r\n\r\nNest.js adopta una arquitectura modular inspirada en Angular, donde los decoradores y las clases juegan un papel clave. Este enfoque modular facilita la organización del código en módulos independientes, lo que resulta ideal para proyectos escalables y basados en microservicios. En comparación con otros frameworks modernos como **Express** o **Fastify**, Nest.js destaca por ofrecer una estructura más clara y robusta, reduciendo el esfuerzo de configuración y permitiendo un desarrollo más organizado desde el inicio. También incluye soporte nativo para patrones de inyección de dependencias.\r\n\r\n### Comparación\r\n\r\n- **Nest.js** ofrece un diseño más moderno y modular desde el principio.\r\n- **Spring** es más maduro y flexible, permitiendo tanto arquitecturas tradicionales como modernas.\r\n\r\n\r\n## Ecosistema de Spring\r\n\r\nEl ecosistema de Spring es amplio y consolidado, con herramientas como:\r\n\r\n- **Spring Boot:** Simplifica la configuración y el despliegue de aplicaciones.\r\n- **Spring Data:** Facilita la interacción con bases de datos.\r\n- **Spring Security:** Proporciona un sistema robusto para la gestión de autenticación y autorización.\r\n- **Spring Web:** Ofrece un conjunto completo de herramientas para desarrollar aplicaciones web.\r\n\r\nSu comunidad es una de las más grandes del mundo del desarrollo backend, ofreciendo soporte comercial y una extensa documentación.\r\n\r\n\r\n## Ecosistema de Nest.js\r\n\r\nAunque más joven, Nest.js cuenta con un ecosistema en rápido crecimiento. Ofrece integraciones modernas para:\r\n\r\n- **Bases de datos:** TypeORM, Prisma, Mongoose.\r\n- **APIs avanzadas:** GraphQL, WebSockets.\r\n- **Microservicios:** Herramientas para crear y gestionar servicios distribuidos.\r\n\r\nLa comunidad de Nest.js es activa y está en constante expansión, aunque todavía no iguala el tamaño de la comunidad de Spring.\r\n\r\n\r\n## Lenguaje de programación: Java vs TypeScript\r\n\r\nSpring se basa en **Java**, un lenguaje robusto y ampliamente utilizado en entornos empresariales. También es compatible con otros lenguajes como **Kotlin** y **Groovy**, ofreciendo cierta flexibilidad.\r\n\r\nNest.js está escrito en **TypeScript**, un superconjunto de **JavaScript** con tipado estático. Esto lo hace especialmente atractivo para desarrolladores provenientes del frontend o aquellos que buscan un lenguaje moderno para proyectos ágiles.\r\n\r\n### Comparación: Java o TypeScript\r\n\r\n- **Java** destaca en aplicaciones empresariales críticas, ofreciendo una base sólida para proyectos a gran escala y largo plazo.\r\n- **TypeScript** se presenta como la opción moderna para equipos ágiles que prefieren trabajar con tecnologías frontend y desean aprovechar el tipado estático para mejorar la calidad y productividad del código.\r\n\r\n\r\n## Facilidad de uso\r\n\r\n- **Spring** tiene una curva de aprendizaje pronunciada debido a su flexibilidad y potencia. Sin embargo, **Spring Boot** simplifica considerablemente la configuración inicial, permitiendo crear aplicaciones listas para producción en poco tiempo.\r\n- **Nest.js** es más intuitivo y amigable para principiantes, especialmente para quienes ya están familiarizados con TypeScript. Su estructura modular y sus generadores de código facilitan el desarrollo.\r\n\r\n\r\n## Rendimiento\r\n\r\nEl rendimiento es un factor crítico en el desarrollo backend y debe evaluarse en términos de consumo de CPU, uso de memoria e impacto general en los costos de desarrollo.\r\n\r\n### CPU\r\n\r\n- **Nest.js:** Construido sobre Node.js, utiliza un modelo de bucle de eventos de un solo hilo. Esto lo hace muy eficiente para aplicaciones intensivas en I/O. Algunos benchmarks muestran hasta un **20% menos de uso de CPU** en estos casos en comparación con modelos multihilo.\r\n- **Spring Framework:** Basado en Java, utiliza un modelo multihilo. Esto lo hace más eficiente para tareas intensivas en CPU, ofreciendo hasta un **30% mejor rendimiento** en esos escenarios.\r\n\r\n### Memoria\r\n\r\n- **Nest.js:** Gracias a su diseño modular y minimalista, puede reducir el uso de memoria hasta en un **40%** en aplicaciones similares construidas con Spring Framework.\r\n- **Spring Framework:** Consume más memoria debido a su amplio conjunto de funcionalidades. Una aplicación empresarial típica puede requerir **200–300 MB** más de memoria que su equivalente en Nest.js.\r\n\r\n### Costos de desarrollo\r\n\r\n- **Nest.js:** Al estar basado en JavaScript, un lenguaje conocido por el **67.7% de los desarrolladores**, puede acortar la curva de aprendizaje y reducir costos de desarrollo si el equipo ya domina este lenguaje.\r\n- **Spring Framework:** Puede requerir conocimientos especializados en Java, lo que podría aumentar los costos de capacitación si el equipo no tiene experiencia previa.\r\n\r\n\r\n## Conclusiones\r\n\r\n¿Cómo elegir entre Nest.js y Spring Framework? En gran medida depende de las necesidades específicas de tu proyecto y de la experiencia de tu equipo de desarrollo.\r\n\r\n**Nest.js**, basado en JavaScript moderno, es una opción accesible para equipos con experiencia en JavaScript. Su arquitectura más ligera y su menor consumo de memoria pueden traducirse en un uso más eficiente de recursos y tiempos de desarrollo más rápidos. Además, su modelo de bucle de eventos de un solo hilo es perfecto para aplicaciones intensivas en I/O.\r\n\r\nPor otro lado, **Spring Framework** destaca por su conjunto robusto de características y su modelo multihilo, ideal para tareas más complejas e intensivas en CPU. Aunque su uso de memoria y sus costos de desarrollo pueden ser mayores debido a Java, la amplia funcionalidad que ofrece puede compensar esas desventajas en ciertos proyectos.\r\n\r\nLa clave para elegir entre estos frameworks es comprender completamente los requisitos del proyecto y evaluar cuidadosamente los pros y contras de cada uno. Con esta información, podrás asegurar el éxito de tu proyecto.","src/content/blog/es/nest-vs-spring.mdx","c6fdf8730d2c4b51","es/migration-from-next-to-astro",{id:946,data:948,body:953,filePath:954,digest:955,deferredRender:37},{title:949,description:950,date:951,tags:952,lang:150},"Migrando de Next.js a Astro","Por qué decidí migrar de Next.js a Astro y cómo me simplificó el mantenimiento de mi sitio y la actualización de contenido.",["Date","2025-10-21T03:00:00.000Z"],[910,911],"Durante mucho tiempo usé **Next.js** para mi sitio personal y mi blog. Siempre me gustó trabajar con **React**, así que Next me parecía la opción más natural. Pero con el tiempo empecé a notar algo: mantener un sitio estático con Next era más complicado de lo que debería.\r\n\r\nCada vez que quería agregar un nuevo post o actualizar información, tenía que tocar el código, regenerar todo y esperar el build. Y como no tengo un CMS ni una base de datos conectada, todo era contenido estático. En teoría eso debería ser lo más simple del mundo… pero en Next no lo sentía así.\r\n\r\n---\r\n\r\n## Next.js es genial, pero no para todo\r\n\r\nNo hay duda: Next.js es una herramienta poderosa. Si estás construyendo una app compleja, un panel administrativo o algo que necesite SSR, API routes y autenticación, es una joya.\r\n\r\nEl problema es cuando tu proyecto **no necesita todo eso**.  \r\nUn simple blog, un portfolio o un sitio con contenido estático termina arrastrando mucho más peso del necesario.\r\n\r\nAlgunas cosas que me frustraban:\r\n\r\n- El **bundle era demasiado grande** incluso para páginas simples.\r\n- Agregar contenido requería configurar **contentlayer** o alguna otra solución extra.\r\n- Cada nuevo post implicaba modificar rutas o hacer rebuild completo.\r\n- La configuración inicial era cada vez más compleja.\r\n\r\nLlega un punto donde sentís que estás usando un **framework demasiado grande para un problema chico**.  \r\nComo usar un martillo neumático para clavar una chinche.\r\n\r\n---\r\n\r\n## Y ahí apareció Astro\r\n\r\nUn día, sin muchas expectativas, empecé a probar **Astro**.  \r\nY fue un cambio total.\r\n\r\nLo primero que me sorprendió fue **lo fácil que es crear cosas**.  \r\nAstro tiene una filosofía muy distinta: _“Content-first”_.  \r\nEstá pensado para sitios que priorizan el contenido, no las apps.\r\n\r\nPude crear un blog completamente funcional en minutos, sin instalar nada extra.  \r\nNo necesité configurar contentlayer, ni preocuparme por el routing. Simplemente creás un archivo Markdown en `src/content`, y Astro se encarga del resto: genera las rutas, te da tipado automático y hasta valida los metadatos.\r\n\r\nAdemás, el **rendimiento es increíble**. Astro genera HTML estático por defecto y no carga nada de JavaScript a menos que vos lo pidas. Eso significa que tu sitio es rápido, liviano y eficiente.\r\n\r\n---\r\n\r\n## Sigo usando React (pero como una isla)\r\n\r\nAlgo que me encantó es que no tuve que dejar atrás React.  \r\nAstro me permite usarlo **solo cuando realmente lo necesito**, como una “isla” dentro del sitio.\r\n\r\nPor ejemplo, para un componente interactivo o un efecto visual puntual, puedo seguir usando mis componentes React de siempre, con todo su ecosistema (hooks, props, etc.), pero sin que afecten el rendimiento general del sitio.\r\n\r\nNo tuve que rehacer todo en TypeScript “vanilla”, ni cambiar mi forma de pensar en componentes.  \r\nAstro simplemente me da la libertad de elegir **cuándo y dónde** usar React.\r\n\r\n---\r\n\r\n## Comparando la experiencia\r\n\r\n| Aspecto              | Next.js                                  | Astro                               |\r\n| -------------------- | ---------------------------------------- | ----------------------------------- |\r\n| Tamaño del bundle    | Alto, incluso en sitios simples          | Mínimo por defecto                  |\r\n| Manejo de contenido  | Requiere contentlayer u otra herramienta | Integrado con `content collections` |\r\n| Curva de aprendizaje | Alta para sitios estáticos               | Muy baja                            |\r\n| Performance          | Buena, pero con más JS                   | Excelente, 0 JS por defecto         |\r\n| React                | Totalmente dependiente                   | Opcional, solo donde se necesita    |\r\n\r\n---\r\n\r\n## Mi flujo actual\r\n\r\nHoy en día, escribir un nuevo post en mi blog es literalmente **crear un archivo Markdown**.  \r\nAstro se encarga de todo: rutas, layouts, tipado y renderizado.\r\n\r\nUso **TailwindCSS** para los estilos y **React** para los componentes interactivos (como menús o efectos visuales).  \r\nTodo lo demás es contenido estático, limpio y veloz.\r\n\r\nNo tengo que preocuparme por el bundle, ni por dependencias innecesarias.  \r\nSimplemente escribo y publico.\r\n\r\n---\r\n\r\n## Conclusión\r\n\r\nMigrar a Astro me simplificó muchísimo las cosas.  \r\nAhora, si quiero **agregar nueva información o actualizar algo**, lo puedo hacer sin complicaciones, sin configurar herramientas extra o tocar demasiadas partes del proyecto.\r\n\r\nAntes, con Next, modificar algo tan simple como un texto o una sección implicaba más pasos de los necesarios.  \r\nCon Astro, todo se siente más directo: abrís un archivo, lo cambiás, y listo.\r\n\r\nNo fue un cambio solo de tecnología, sino de **flujo de trabajo**.  \r\nAhora mantener mi sitio es mucho más ágil, liviano y, sobre todo, práctico.","src/content/blog/es/migration-from-next-to-astro.mdx","bab53889f99fca1f","es/working-with-react-useeffect-hook",{id:956,data:958,body:963,filePath:964,digest:965,deferredRender:37},{title:959,description:960,date:961,tags:962,lang:150},"Rendering y Re-Rendering en React","En este articulo aprenderás lo que hay detras de un “rerender” en React, qué los provoca, cómo evitarlos y patrones a tener en cuenta para optimizar nuestras aplicaciones.",["Date","2024-11-06T03:00:00.000Z"],[910,922],"## Introducción\r\n\r\nComprender los conceptos clave de una librería es esencial para sentirse cómodo trabajando con ella. Por eso decidí escribir este artículo sobre la piedra angular que dio origen a React: los 'renders'. Aunque React ha evolucionado significativamente en los últimos meses, su esencia permanece intacta: crear interfaces basadas en componentes que retornan JSX.\r\n\r\nDominar el proceso de 'renderizado' y los eventos que lo desencadenan es crucial para diseñar aplicaciones eficientes y construir una base sólida para la mejora continua. Al final del día, trabajar con React siempre nos lleva a discutir sobre 'renders', así que ¿por qué no entenderlos a fondo desde el principio?\r\n\r\n## ¿Qué es un 'Render' en React?\r\n\r\nComencemos entendiendo qué significa 'render' en React. Esencialmente, un 'render' es el proceso por el cual React envía el JSX retornado por un componente al DOM. Este JSX se calcula a partir de tres elementos clave:\r\n\r\n- Las propiedades (props) que el componente recibe.\r\n- El estado interno del componente.\r\n- Los valores de los contextos que el componente consume a través de la Context API.\r\n\r\nUn componente se renderiza siempre que forme parte del árbol de componentes que hemos definido.\r\n\r\n![Árbol de Componentes](https://res.cloudinary.com/dhu8pktj2/image/upload/v1733336511/blog/render%20and%20rerender/tmo1gem70yyqaffag77k.png)\r\n\r\nCuando el navegador carga nuestra aplicación por primera vez, React genera un árbol de componentes. Cada componente retorna piezas de JSX que, al combinarse, definen la estructura completa de la interfaz. Sin embargo, esta estructura no es estática. A medida que el usuario interactúa con la aplicación, el árbol de componentes puede cambiar de varias maneras:\r\n\r\n- Agregando nuevos componentes.\r\n- Eliminando componentes existentes.\r\n- Modificando el estado o las props de componentes ya presentes.\r\n\r\nEl momento clave en este proceso es el 'render inicial', que ocurre cuando un componente aparece por primera vez en el árbol. Durante este primer render, el componente establece los valores iniciales de su estado.\r\n\r\nA partir de ahí, entramos en el reino de los 'rerenders', donde las cosas se ponen realmente interesantes.\r\n\r\n## ¿Qué son los 'Re-renders'?\r\n\r\nUn 're-render' es cualquier renderizado de un componente que ya está en el DOM y no corresponde al 'render inicial'.\r\n\r\nLos re-renders ocurren cuando hay un cambio en el estado de la aplicación, causado por:\r\n\r\n- Acciones del usuario, como interactuar con un elemento de la interfaz.\r\n- Actualizaciones externas, como la llegada de datos de una API mediante una llamada fetch.\r\n\r\n### Tipos de 'Re-renders'\r\n\r\nPodemos clasificar los re-renders en dos categorías principales:\r\n\r\n- **Re-renders necesarios**: Son renders donde el componente se ve directamente afectado por un cambio, y su nuevo JSX diferirá del anterior. Ejemplo: En un contador, cuando el usuario presiona el botón para incrementarlo, el componente necesita un nuevo render para mostrar el valor actualizado.\r\n- **Re-renders innecesarios**: Ocurren cuando un componente se re-renderiza aunque no haya sido afectado por el cambio y genera el mismo JSX que en el render anterior.\r\n\r\nCausa común: Una estructura ineficiente o mala planificación de nuestra aplicación.\r\n\r\nLos re-renders innecesarios pueden afectar el rendimiento de la aplicación, por lo que identificarlos y evitarlos es clave para mantener una experiencia de usuario fluida.\r\n\r\n## Razones por las que un Componente se Re-renderiza\r\n\r\nUn componente puede re-renderizarse por una de las siguientes razones:\r\n\r\n- Cambio en el estado interno (declarado usando useState), generalmente como resultado de una acción del usuario, como hacer clic en un botón.\r\n- Cambio en el contexto, si el componente está consumiendo un contexto y su valor se actualiza.\r\n- Re-render del componente padre, que causa, por defecto, que todos los componentes hijos se re-rendericen.\r\n\r\nVeamos estos casos más de cerca:\r\n\r\n### Cambios en el Estado\r\n\r\nCuando declaramos una pieza de estado dentro de un componente usando el hook useState, cualquier cambio en ese estado, desencadenado por invocar setState, causará un re-render del componente.\r\n\r\n```javascript\r\nexport const Counter = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Incrementar</button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n> **Nota:** Cada vez que el estado se actualiza con setCount, el componente se renderiza nuevamente.\r\n\r\n### Cambio en el Contexto\r\n\r\nCuando el valor de un contexto cambia, todos los componentes que están consumiendo ese contexto mediante el hook useContext se re-renderizarán para asegurar que la vista refleje la actualización.\r\n\r\n```javascript\r\nconst ContContext = createContext(0);\r\n\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <ContContext.Provider value={count}>\r\n      <Counter />\r\n    </ContContext.Provider>\r\n  );\r\n}\r\n```\r\n\r\n> **Nota:** Cuando el estado count cambia, el contexto en el Provider recibe un nuevo valor. Como resultado, todos los componentes usando useContext(ContContext) detectan este cambio y se re-renderizan automáticamente.\r\n\r\n### Re-renderizado del Componente Padre\r\n\r\nPor defecto, un componente hijo se re-renderizará siempre que su componente padre lo haga. En otras palabras, cuando un componente se re-renderiza, todos sus componentes hijos también se re-renderizan, incluso si no hay cambios directos en ellos.\r\n\r\n```javascript\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Component />\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Component() {\r\n ...\r\n}\r\n```\r\n\r\n> **Nota:** En este caso, el componente Component se re-renderiza cada vez que el componente App lo hace.\r\n\r\n## Cómo Prevenir Re-renders Innecesarios\r\n\r\nAhora que conocemos las razones por las que un componente puede renderizarse, exploremos algunas técnicas que nos ayudarán a prevenir re-renders innecesarios y optimizar el rendimiento de nuestras aplicaciones.\r\n\r\n### Colocar el Estado lo Más Abajo Posible\r\n\r\nEsta técnica es útil cuando trabajamos con componentes complejos que manejan múltiples estados, especialmente si algunos de ellos solo se usan en partes específicas del árbol de componentes.\r\n\r\n![Árbol de Componentes con Estado](https://res.cloudinary.com/dhu8pktj2/image/upload/v1733499382/blog/render%20and%20rerender/gbarvy0hgjckm8iuv7mo.png)\r\n\r\nPor ejemplo, si stateFour solo es relevante para ComponentFour, mantenerlo en un nivel superior causará que cualquier cambio en este estado desencadene un render de todo el árbol (recuerda: renderizar un componente padre también re-renderiza todos sus hijos). Esto puede ser ineficiente.\r\n\r\nPara evitar este problema, podemos definir stateFour directamente en ComponentFour, limitando su impacto y asegurando que los cambios solo afecten al componente que realmente lo necesita.\r\n\r\n![Árbol de Componentes con Estado Modificado](https://res.cloudinary.com/dhu8pktj2/image/upload/v1733499408/blog/render%20and%20rerender/u2wjqegjlv0n7sk6axeu.png)\r\n\r\n### Pasar Componentes como Props\r\n\r\nEsta técnica es especialmente útil cuando trabajamos con componentes costosos de renderizar que están contenidos dentro de un componente que se renderiza frecuentemente, como un formulario que maneja inputs.\r\n\r\n```javascript\r\nconst FormComponent = () => {\r\n  // Lógica y estado del componente\r\n\r\n  return (\r\n    <div>\r\n      <input type=\"text\" placeholder=\"Input 1\" />\r\n      <input type=\"text\" placeholder=\"Input 2\" />\r\n      <SlowComponent />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nCada vez que FormComponent se renderiza, los inputs y SlowComponent también se re-renderizan, lo que puede afectar negativamente el rendimiento.\r\n\r\nPara evitar este problema, podemos pasar el componente costoso como una prop, por ejemplo, usando children. Esto funciona porque children es solo una referencia al componente, y React no lo re-renderiza a menos que cambie explícitamente. Es como si el componente ya estuviera 'pre-renderizado'.\r\n\r\n```javascript\r\nconst ParentComponent = () => {\r\n  return (\r\n    <FormComponent>\r\n      <SlowComponent />\r\n    </FormComponent>\r\n  );\r\n};\r\n\r\nconst FormComponent = ({ children }) => {\r\n  return (\r\n    <div>\r\n      <input type=\"text\" placeholder=\"Input 1\" />\r\n      <input type=\"text\" placeholder=\"Input 2\" />\r\n      {children}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nEsta técnica, conocida como 'envolver el estado alrededor de los children', es muy útil para optimizar casos similares.\r\n\r\n> **Nota:** Este enfoque no se limita a la prop children: podemos definir cualquier número de props en un componente y usar este patrón para prevenir renders innecesarios.\r\n\r\n### Evitar Crear Componentes Dentro de Otros\r\n\r\nEs importante evitar un anti-patrón que puede causar problemas significativos de rendimiento: definir un componente dentro de otro.\r\n\r\n```javascript\r\nfunction SomeComponent() {\r\n  const OtherComponent = () => {\r\n    const [state, setState] = useState();\r\n    useEffect(() => {\r\n      // Lógica del efecto\r\n    }, []);\r\n\r\n    return <div>Contenido del componente</div>;\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <OtherComponent />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\nEste código incluye el componente OtherComponent definido dentro de SomeComponent, lo cual es un anti-patrón en React porque causa que OtherComponent se vuelva a montar y ejecute todos sus efectos cada vez que SomeComponent se renderiza. Esto puede ser ineficiente y llevar a problemas de rendimiento.\r\n\r\n## Memoizar componentes con React.memo\r\n\r\nLa función memo de React nos permite optimizar componentes funcionales envolviéndolos para evitar renders innecesarios. Si las props del componente no han cambiado desde el render anterior, React reutiliza el resultado previo, mejorando el rendimiento. Para quienes han trabajado con componentes de clase, memo se comporta de manera similar a la función shouldComponentUpdate, que permitía decidir si un componente debía actualizarse. Veamos cómo usar memo con algunos ejemplos prácticos.\r\n\r\n### Componente sin propiedades\r\n\r\nEn este caso, el componente que estamos envolviendo con React.memo no recibe ninguna prop. Como resultado, este componente no se re-renderizará incluso cuando el componente padre se renderice, ya que no depende de datos externos.\r\n\r\nEsto hace que la optimización sea aún más simple, ya que no necesitamos verificar si las props han cambiado porque no hay props que verificar.\r\n\r\n```javascript\r\nconst NoPropsComponent = React.memo(() => {\r\n  console.log(\"Renderizando NoPropsComponent\");\r\n  return <div>Este componente no tiene props</div>;\r\n});\r\n\r\nconst ParentComponent = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\r\n        Incrementar\r\n      </button>\r\n      <NoPropsComponent />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n> **Nota:** En este ejemplo, cada vez que ParentComponent se renderiza (por ejemplo, cuando count se incrementa), NoPropsComponent no se re-renderiza ya que no tiene props y su renderizado no depende de ningún cambio en el estado del componente padre.\r\n\r\n### Componente con propiedades\r\n\r\nCuando un componente memoizado con React.memo recibe props, solo se re-renderizará si una de esas props cambia. Si las props no cambian entre renders, React evitará re-renders innecesarios, lo que puede mejorar el rendimiento.\r\n\r\n```javascript\r\nconst ExpensiveComponent = React.memo(({ value }) => {\r\n  console.log(\"Renderizando ExpensiveComponent\");\r\n  return <div>El valor es: {value}</div>;\r\n});\r\n\r\nconst ParentComponent = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [value, setValue] = useState(\"valor inicial\");\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\r\n        Incrementar\r\n      </button>\r\n      <button\r\n        onClick={() =>\r\n          setValue((prevValue) =>\r\n            prevValue === \"valor inicial\" ? \"nuevo valor\" : \"valor inicial\"\r\n          )\r\n        }\r\n      >\r\n        Cambiar valor\r\n      </button>\r\n      <ExpensiveComponent value={value} />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n> **Nota:** En este ejemplo, ExpensiveComponent solo se re-renderizará si el valor de `value` cambia. Incluso si el estado `count` en ParentComponent cambia (cuando se hace clic en el primer botón), ExpensiveComponent no se re-renderizará si `value` no cambia.\r\n\r\n### Combinar useMemo / useCallback con memo\r\n\r\nEn React, `memo` es una herramienta poderosa para evitar renders innecesarios de un componente, pero ¿qué sucede cuando las props del componente son funciones, objetos o arrays? En estos casos, `memo` no funcionará como se espera a menos que usemos los hooks apropiados. Veamos cómo podemos mejorar esto.\r\n\r\nCuando pasamos funciones u objetos como props a un componente memoizado, si esos valores cambian en cada render, la memoización no tendrá efecto. Esto se debe a que React trata las nuevas funciones u objetos como valores diferentes, incluso si el contenido es el mismo. Veamos esto en algunos ejemplos.\r\n\r\n```javascript\r\nimport { memo } from \"react\";\r\n\r\nconst Child = ({ onClick }) => <button onClick={onClick}>Haz clic</button>;\r\n\r\nconst MemorizedChild = memo(Child);\r\n\r\nconst Parent = () => {\r\n  const handleClick = () => console.log(\"¡Clic!\");\r\n\r\n  return (\r\n    <div>\r\n      <MemorizedChild onClick={handleClick} />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nEn este ejemplo, el componente `Parent` crea una nueva función `handleClick` en cada render. Aunque la lógica de la función es la misma, React crea una nueva referencia cada vez, lo que causa que `MemorizedChild` reciba un nuevo valor para `onClick` y se re-renderice innecesariamente.\r\n\r\nOtro caso común es cuando pasamos un objeto como prop. Veamos el siguiente ejemplo.\r\n\r\n```javascript\r\nimport { memo } from \"react\";\r\n\r\nconst Child = ({ pet }) => <div>{pet.name}</div>;\r\n\r\nconst MemorizedChild = memo(Child);\r\n\r\nconst Parent = () => {\r\n  const pet = { name: \"Fido\" };\r\n\r\n  return (\r\n    <div>\r\n      <MemorizedChild pet={pet} />\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nEn este caso, `Parent` crea un nuevo objeto `pet` en cada render. Aunque el contenido del objeto no cambia, su referencia sí lo hace, causando que `MemorizedChild` reciba un nuevo objeto en cada render y se re-renderice innecesariamente.\r\n\r\nAfortunadamente, React proporciona los hooks `useMemo` y `useCallback` para prevenir la creación de nuevas instancias de objetos y funciones en cada render. Veamos cómo podemos mejorar estos ejemplos.\r\n\r\nEl hook `useMemo` memoiza un valor calculado entre renders y solo lo recalcula si sus dependencias cambian. Toma dos parámetros:\r\n\r\n1. Una función que retorna el valor a ser memoizado.\r\n2. Un array de dependencias, similar al hook `useEffect`. La función solo se ejecutará si las dependencias cambian.\r\n\r\nPor otro lado, `useCallback` memoiza funciones de la misma manera. Toma dos parámetros:\r\n\r\n1. La función a ser memoizada.\r\n2. Un array de dependencias. Si alguna de las dependencias cambia, la función se recalcula; de lo contrario, se reutiliza la misma instancia.\r\n\r\n```javascript\r\nimport { useMemo, useCallback } from \"react\";\r\n\r\nconst ParentComponent = ({ name }) => {\r\n  const pet = useMemo(() => ({ name }), [name]);\r\n\r\n  const logName = useCallback(() => {\r\n    console.log(name);\r\n  }, [name]);\r\n\r\n  return <div>...</div>;\r\n};\r\n```\r\n\r\nCon esto, los ejemplos anteriores pueden mejorarse para evitar renders innecesarios. Veamos cómo aplicar `useMemo` y `useCallback` para mejorar los ejemplos.\r\n\r\nPara el caso de la función `onClick`, podemos memoizarla con `useCallback`, asegurando que su referencia nunca cambie entre renders.\r\n\r\n```javascript\r\nimport { memo, useCallback } from \"react\";\r\n\r\nconst Child = ({ onClick }) => <button onClick={onClick}>Presionar</button>;\r\n\r\nconst MemorizedChild = memo(Child);\r\n\r\nconst Parent = () => {\r\n  const handleClick = useCallback(() => {\r\n    console.log(\"Clic\");\r\n  }, []);\r\n\r\n  return <MemorizedChild onClick={handleClick} />;\r\n};\r\n```\r\n\r\nAhora, incluso si `Parent` se re-renderiza, `handleClick` no se recreará porque `useCallback` memoiza la función.\r\n\r\n## Conclusiones\r\n\r\nCon este artículo, hemos cubierto varias técnicas de React para evitar renders innecesarios, lo que puede mejorar significativamente el rendimiento de tus aplicaciones.\r\n\r\nMi consejo es que primero te familiarices con las diferentes causas que pueden desencadenar un re-render y aprendas a identificar qué componentes son susceptibles de optimización. Con los enfoques que he explicado, podrás hacer tu aplicación más eficiente mientras también obtienes una mejor comprensión de cómo funciona el sistema de renderizado de React.\r\n\r\nDominar estas técnicas no solo te permitirá escribir código más eficiente, sino también profundizar tu comprensión de cómo React maneja las actualizaciones de la UI y el renderizado, lo cual es clave para construir aplicaciones rápidas y de alto rendimiento.","src/content/blog/es/working-with-react-useeffect-hook.mdx","d9dae70318d65364"];

export { _astro_dataLayerContent as default };
